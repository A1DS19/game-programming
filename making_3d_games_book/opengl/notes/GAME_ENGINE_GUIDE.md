# Complete Step-by-Step 3D Game Engine Creation Guide

This guide documents the complete process of creating a 3D game engine from the ground up using C++, OpenGL for rendering, and SDL for windowing and input. The engine is designed with a modern, data-driven approach using an Actor/Component architecture and features a robust rendering pipeline with support for 3D meshes, lighting, and UI.

## Table of Contents
1. [Project Setup](#1-project-setup)
2. [Window Creation and OpenGL Context](#2-window-creation-and-opengl-context)
3. [Basic Renderer Setup](#3-basic-renderer-setup)
4. [Shader System](#4-shader-system)
5. [Math Library](#5-math-library)
6. [Actor and Component System](#6-actor-and-component-system)
7. [Mesh Loading and Rendering](#7-mesh-loading-and-rendering)
8. [Lighting System](#8-lighting-system)
9. [Camera and Movement](#9-camera-and-movement)
10. [Input Handling](#10-input-handling)
11. [Game Loop Integration](#11-game-loop-integration)
12. [Advanced Features](#12-advanced-features)

---

## 1. Project Setup

Before writing any code, we need to set up a solid foundation for our project. This involves establishing a clean directory structure and configuring a build system.

### Dependencies Required
- **SDL2**: A cross-platform development library designed to provide low-level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D. We will use it for window creation and input handling.
- **GLEW**: The OpenGL Extension Wrangler Library. It helps in querying and loading OpenGL extensions, which is essential for accessing functions in modern OpenGL versions (3.3+).
- **CMake**: A build system generator. It allows us to define our project structure and dependencies in a platform-agnostic way, generating native build files (like Makefiles or Visual Studio projects).

### Directory Structure
A well-organized directory structure is crucial for maintainability.

```
project/
├── CMakeLists.txt    # Build system configuration
├── include/          # Header files (.hpp) for our engine
├── src/              # Source files (.cpp)
├── shaders/          # GLSL shader files (.vert, .frag)
├── assets/           # Game assets (textures, meshes, sounds)
└── build/            # Build output (generated by CMake)
```

### CMakeLists.txt Setup
This file tells CMake how to build our project.

```cmake
# Require a minimum version of CMake
cmake_minimum_required(VERSION 3.10)
# Define the project name
project(GameEngine)

# Find required libraries (packages)
# CMake will search for these libraries on your system.
find_package(SDL2 REQUIRED)
find_package(GLEW REQUIRED)
find_package(OpenGL REQUIRED)

# Use file(GLOB_RECURSE...) to automatically find all source and header files.
# This saves us from having to list every new file manually.
file(GLOB_RECURSE SOURCES "src/*.cpp")
file(GLOB_RECURSE HEADERS "include/*.hpp")

# Create the executable target
add_executable(${PROJECT_NAME} ${SOURCES} ${HEADERS})

# Tell the compiler where to find our header files
target_include_directories(${PROJECT_NAME} PRIVATE include)

# Link the executable against the libraries we need
target_link_libraries(${PROJECT_NAME} SDL2::SDL2 GLEW::GLEW OpenGL::GL)
```

---

## 2. Window Creation and OpenGL Context

The first step in our code is to get a window to appear on the screen. The `Game` class will be the central hub of our engine, managing the main loop and all game objects.

### Step 2.1: Create the Main Game Class

`include/Game.hpp` defines the interface for our `Game` class.

```cpp
#pragma once
#include <SDL2/SDL.h>
#include <vector>

// Forward-declare classes to avoid circular dependencies
class Actor;
class Renderer;
class CameraActor;

class Game {
public:
    // Define screen dimensions as constants
    static constexpr float SCREEN_WIDTH = 1024.0f;
    static constexpr float SCREEN_HEIGHT = 768.0f;

    Game();
    bool Initialize(); // Initializes the game and all subsystems
    void RunLoop();    // Runs the main game loop until the game is over
    void Shutdown();   // Shuts down all subsystems and cleans up memory

    // Actor management
    void AddActor(Actor* actor);
    void RemoveActor(Actor* actor);

    // Getters
    class Renderer* GetRenderer() { return mRenderer; }

private:
    // Core game loop functions
    void ProcessInput(); // Process user input
    void UpdateGame();   // Update game state
    void GenerateOutput(); // Render the scene

    // Data loading
    void LoadData();
    void UnloadData();

    // All actors in the game world
    std::vector<Actor*> mActors;
    // Actors waiting to be added to the world
    std::vector<Actor*> mPendingActors;
    
    // The main renderer
    class Renderer* mRenderer;
    // Track elapsed time
    Uint32 mTicksCount;
    // Game loop flag
    bool mIsRunning;
    // Flag to prevent modifying actor list while iterating
    bool mUpdatingActors;
    
    // The player's camera
    CameraActor* mCameraActor;
};
```

### Step 2.2: Implement Game Initialization

`src/Game.cpp` contains the implementation. Here, we initialize SDL and create our `Renderer`, which will in turn create the OpenGL context.

```cpp
#include "Game.hpp"
#include "Renderer.hpp"
#include "SDL_log.h"
#include "SDL_timer.h"

Game::Game() : mRenderer{nullptr}, mIsRunning{true}, mUpdatingActors{false} {}

bool Game::Initialize() {
    // Try to initialize SDL with video and audio support
    int sdlResult = SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);
    if (sdlResult != 0) {
        SDL_Log("Failed to initialize with audio: %s", SDL_GetError());
        // If audio fails, fall back to video only
        sdlResult = SDL_Init(SDL_INIT_VIDEO);
        if (sdlResult != 0) {
            SDL_Log("Unable to initialize SDL: %s", SDL_GetError());
            return false;
        }
    }

    // Create the renderer, which will create the window and OpenGL context
    mRenderer = new Renderer(this);
    if (!mRenderer->Initialize(SCREEN_WIDTH, SCREEN_HEIGHT)) {
        SDL_Log("Failed to initialize renderer");
        delete mRenderer;
        mRenderer = nullptr;
        return false;
    }

    // Load initial game data (actors, etc.)
    LoadData();
    // Initialize the tick counter for delta time calculation
    mTicksCount = SDL_GetTicks();
    return true;
}
```

### Step 2.3: Main Entry Point

`src/main.cpp` is the entry point of our application. It creates a `Game` instance and runs it.

```cpp
#include "Game.hpp"

int main() {
    Game game;
    bool success = game.Initialize();

    if (success) {
        game.RunLoop();
    }

    game.Shutdown();
    return 0;
}
```

---

## 3. Basic Renderer Setup

The `Renderer` class is responsible for all drawing. It manages the SDL window, the OpenGL context, and all rendering resources like shaders and meshes.

### Step 3.1: Create Renderer Class

`include/Renderer.hpp` defines the `Renderer`'s interface.

```cpp
#pragma once
#include "Math.hpp"
#include "SDL_video.h"
#include <string>
#include <unordered_map>
#include <vector>

// A simple struct for a directional light source
struct DirectionalLight {
    Vector3 mDirection;    // Direction of the light
    Vector3 mDiffuseColor; // Color of the diffuse light
    Vector3 mSpecColor;    // Color of the specular highlight
};

class Renderer {
public:
    Renderer(class Game* game);
    ~Renderer();

    bool Initialize(float screenWidth, float screenHeight);
    void Shutdown();
    void Draw(); // Draw the entire scene

    // Component management
    void AddSprite(class SpriteComponent* sprite);
    void RemoveSprite(class SpriteComponent* sprite);
    void AddMeshComp(class MeshComponent* mesh);
    void RemoveMeshComp(class MeshComponent* mesh);

    // Resource management
    class Texture* GetTexture(const std::string& fileName);
    class Mesh* GetMesh(const std::string& fileName);

    // Setters for view matrix and lighting
    void SetViewMatrix(const Matrix4& view) { mView = view; }
    void SetAmbientLight(const Vector3& ambient) { mAmbientLight = ambient; }
    DirectionalLight& GetDirectionalLight() { return mDirLight; }

    // Getters
    float GetScreenWidth() const { return mScreenWidth; }
    float GetScreenHeight() const { return mScreenHeight; }

private:
    bool LoadShaders();
    void CreateSpriteVerts();
    void SetLightUniforms(class Shader* shader);

    // Resource caches
    std::unordered_map<std::string, class Texture*> mTextures;
    std::unordered_map<std::string, class Mesh*> mMeshes;

    // Lists of components to draw
    std::vector<class SpriteComponent*> mSprites; // For UI
    std::vector<class MeshComponent*> mMeshComps; // For 3D objects

    class Game* mGame;
    class Shader* mSpriteShader;
    class Shader* mMeshShader;
    class VertexArray* mSpriteVerts; // Vertex data for drawing all sprites

    // Matrices for 3D rendering
    Matrix4 mView;       // View matrix (camera)
    Matrix4 mProjection; // Projection matrix (perspective)
    float mScreenWidth;
    float mScreenHeight;

    // Lighting data
    Vector3 mAmbientLight;
    DirectionalLight mDirLight;

    // SDL/OpenGL handles
    SDL_Window* mWindow;
    SDL_GLContext mContext;
};
```

### Step 3.2: Implement Renderer Initialization

In `src/Renderer.cpp`, we configure and create the OpenGL 3.3 Core Profile context.

```cpp
#include "Renderer.hpp"
#include "Shader.hpp"
#include "VertexArray.hpp"
#include "Texture.hpp"
#include "Mesh.hpp"
#include <GL/glew.h>
#include <SDL_log.h>

bool Renderer::Initialize(float screenWidth, float screenHeight) {
    mScreenWidth = screenWidth;
    mScreenHeight = screenHeight;

    // Configure OpenGL attributes before creating the context
    // Use OpenGL 3.3 Core Profile
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    // Request 8-bits per color channel
    SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
    // Request a 24-bit depth buffer
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    // Enable double buffering
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    // Use hardware acceleration
    SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);

    // Create the SDL window
    mWindow = SDL_CreateWindow("3D Game Engine", 100, 100,
                              static_cast<int>(mScreenWidth),
                              static_cast<int>(mScreenHeight),
                              SDL_WINDOW_OPENGL);
    if (!mWindow) {
        SDL_Log("Failed to create window: %s", SDL_GetError());
        return false;
    }

    // Create the OpenGL context
    mContext = SDL_GL_CreateContext(mWindow);

    // Initialize GLEW to load OpenGL extensions
    glewExperimental = GL_TRUE;
    if (glewInit() != GLEW_OK) {
        SDL_Log("Failed to initialize GLEW.");
        return false;
    }
    // On some platforms, glewInit can generate a benign error code, so clear it.
    glGetError();

    // Now that we have a context, we can load our shaders
    if (!LoadShaders()) {
        SDL_Log("Failed to load shaders.");
        return false;
    }

    // Create a default vertex array for rendering sprites
    CreateSpriteVerts();

    return true;
}
```

---

## 4. Shader System

Shaders are small programs that run on the GPU and are essential for modern rendering. We'll need a vertex shader (to position vertices) and a fragment shader (to color pixels).

### Step 4.1: Create Shader Class

`include/Shader.hpp` provides an interface to load, unload, and activate a shader program.

```cpp
#pragma once
#include <GL/glew.h>
#include <string>
#include "Math.hpp"

class Shader {
public:
    Shader();
    ~Shader();

    // Load vertex and fragment shaders from file and compile them into a program
    bool Load(const std::string& vertName, const std::string& fragName);
    void Unload();
    
    // Set this as the active shader program
    void SetActive();

    // Functions to set uniform variables in the shader
    void SetMatrixUniform(const char* name, const Matrix4& matrix);
    void SetVectorUniform(const char* name, const Vector3& vector);
    void SetFloatUniform(const char* name, float value);

private:
    // Helper functions to compile a single shader and validate the program
    bool CompileShader(const std::string& fileName, GLenum shaderType, GLuint& outShader);
    bool IsCompiled(GLuint shader);
    bool IsValidProgram();

    // OpenGL IDs for the shaders and program
    GLuint mVertexShader;
    GLuint mFragShader;
    GLuint mShaderProgram;
};
```

### Step 4.2: Implement Shader Loading

`src/Shader.cpp` handles the file I/O and OpenGL calls to create a shader program.

```cpp
#include "Shader.hpp"
#include <SDL_log.h>
#include <fstream>
#include <sstream>

bool Shader::Load(const std::string& vertName, const std::string& fragName) {
    // Compile the vertex and fragment shaders
    if (!CompileShader(vertName, GL_VERTEX_SHADER, mVertexShader) ||
        !CompileShader(fragName, GL_FRAGMENT_SHADER, mFragShader)) {
        return false;
    }

    // Create the shader program and attach the shaders
    mShaderProgram = glCreateProgram();
    glAttachShader(mShaderProgram, mVertexShader);
    glAttachShader(mShaderProgram, mFragShader);
    // Link the program to generate the executable
    glLinkProgram(mShaderProgram);

    // Verify that the program linked successfully
    if (!IsValidProgram()) {
        return false;
    }

    return true;
}

bool Shader::CompileShader(const std::string& fileName, GLenum shaderType, GLuint& outShader) {
    std::ifstream shaderFile(fileName);
    if (shaderFile.is_open()) {
        // Read the entire file into a string
        std::stringstream sstream;
        sstream << shaderFile.rdbuf();
        std::string contents = sstream.str();
        const char* contentsChar = contents.c_str();

        // Create the shader object
        outShader = glCreateShader(shaderType);
        // Provide the source code
        glShaderSource(outShader, 1, &(contentsChar), nullptr);
        // Compile the shader
        glCompileShader(outShader);

        // Check for compilation errors
        if (!IsCompiled(outShader)) {
            SDL_Log("Failed to compile shader %s", fileName.c_str());
            return false;
        }
    } else {
        SDL_Log("Shader file not found: %s", fileName.c_c_str());
        return false;
    }

    return true;
}
```

### Step 4.3: Create Basic Shaders

These are the actual shader programs written in GLSL (OpenGL Shading Language).

`shaders/BasicMesh.vert`: This vertex shader transforms vertex positions from model space to clip space and passes data like normals and texture coordinates to the fragment shader.

```glsl
#version 330

// Input vertex attributes
layout(location = 0) in vec3 inPosition; // Vertex position in model space
layout(location = 1) in vec3 inNormal;   // Vertex normal in model space
layout(location = 2) in vec2 inTexCoord; // Texture coordinate

// Uniforms (global variables) passed from C++
uniform mat4 uWorldTransform; // Model to world space matrix
uniform mat4 uViewProj;       // Combined view-projection matrix

// Outputs passed to the fragment shader (interpolated across the triangle)
out vec2 fragTexCoord;
out vec3 fragNormal;
out vec3 fragWorldPos;

void main() {
    // Transform position to world space
    vec4 pos = vec4(inPosition, 1.0);
    pos = pos * uWorldTransform;
    fragWorldPos = pos.xyz; // Save world position for lighting

    // Transform position to clip space
    gl_Position = pos * uViewProj;
    
    // Transform normal to world space (as a direction)
    fragNormal = (vec4(inNormal, 0.0f) * uWorldTransform).xyz;
    // Pass through texture coordinate
    fragTexCoord = inTexCoord;
}
```

`shaders/BasicMesh.frag`: This simple fragment shader just samples a texture to determine the pixel's color.

```glsl
#version 330

// Inputs from the vertex shader
in vec2 fragTexCoord;
in vec3 fragNormal;
in vec3 fragWorldPos;

// Uniforms
uniform sampler2D uTexture; // The texture to sample from

// Output color for the pixel
out vec4 outColor;

void main() {
    // Sample the texture at the given coordinate
    outColor = texture(uTexture, fragTexCoord);
}
```

---

## 5. Math Library

A solid math library is the backbone of any game engine. We need vectors, matrices, and quaternions.

### Step 5.1: Create Math Header

`include/Math.hpp` contains all our math structures and functions. For a real project, using a library like GLM is recommended, but creating our own is a great learning exercise.

```cpp
#pragma once
#include <cmath>
#include <limits>

// A namespace for common math constants and functions
namespace Math {
    const float Pi = 3.1415926535f;
    const float TwoPi = Pi * 2.0f;
    const float PiOver2 = Pi / 2.0f;
    const float Infinity = std::numeric_limits<float>::infinity();
    const float NegInfinity = -std::numeric_limits<float>::infinity();

    inline float ToRadians(float degrees) { return degrees * Pi / 180.0f; }
    inline float ToDegrees(float radians) { return radians * 180.0f / Pi; }
}

// A 3D vector
struct Vector3 {
    float x, y, z;
    // Constructors, operators, and utility functions...
};

// A quaternion for representing rotations
// Quaternions are used to avoid gimbal lock and for smooth interpolation
struct Quaternion {
    float x, y, z, w;
    // Constructors and utility functions...
};

// A 4x4 matrix for transformations
struct Matrix4 {
    float mat[4][4];
    // Constructors, operators, and utility functions...

    // Static functions to create specific transformation matrices
    static Matrix4 CreateScale(float xScale, float yScale, float zScale);
    static Matrix4 CreateRotationX(float theta);
    static Matrix4 CreateRotationY(float theta);
    static Matrix4 CreateRotationZ(float theta);
    static Matrix4 CreateFromQuaternion(const Quaternion& q);
    static Matrix4 CreateTranslation(const Vector3& trans);
    
    // Functions to create view and projection matrices
    static Matrix4 CreateLookAt(const Vector3& eye, const Vector3& target, const Vector3& up);
    static Matrix4 CreateOrtho(float width, float height, float near, float far);
    static Matrix4 CreatePerspectiveFOV(float fovY, float width, float height, float near, float far);

    static const Matrix4 Identity;
};
```

---

## 6. Actor and Component System

We use an Actor-Component model. **Actors** (or Entities) are the "things" in our game world (e.g., the player, an enemy, a wall). **Components** are reusable modules of data and functionality that we attach to Actors to give them behavior (e.g., a `RenderComponent` to make an actor visible, a `MoveComponent` to make it move).

### Step 6.1: Create Base Actor Class

`include/Actor.hpp` defines the `Actor` class, which is the base for all objects in our game.

```cpp
#pragma once
#include "Math.hpp"
#include <vector>
#include <cstdint>

class Actor {
public:
    // Actors can be in one of three states
    enum State {
        EActive,
        EPaused,
        EDead
    };

    Actor(class Game* game);
    virtual ~Actor();

    // Main update function, called once per frame
    void Update(float deltaTime);
    // Updates all components attached to this actor
    void UpdateComponents(float deltaTime);
    // Actor-specific update logic (can be overridden by subclasses)
    virtual void UpdateActor(float deltaTime);

    // Input processing
    void ProcessInput(const uint8_t* keyState);
    virtual void ActorInput(const uint8_t* keyState);

    // Getters and setters for transform
    const Vector3& GetPosition() const { return mPosition; }
    void SetPosition(const Vector3& pos) { mPosition = pos; mRecomputeWorldTransform = true; }
    float GetScale() const { return mScale; }
    void SetScale(float scale) { mScale = scale; mRecomputeWorldTransform = true; }
    const Quaternion& GetRotation() const { return mRotation; }
    void SetRotation(const Quaternion& rotation) { mRotation = rotation; mRecomputeWorldTransform = true; }

    // Utility functions
    Vector3 GetForward() const;
    State GetState() const { return mState; }
    void SetState(State state) { mState = state; }
    class Game* GetGame() { return mGame; }
    const Matrix4& GetWorldTransform() const { return mWorldTransform; }

    // Component management
    void AddComponent(class Component* component);
    void RemoveComponent(class Component* component);

private:
    // Recalculates the world transform matrix
    void ComputeWorldTransform();

    State mState;
    
    // Transform properties
    Vector3 mPosition;
    Quaternion mRotation;
    float mScale;

    // The final world transform matrix, sent to the shader
    Matrix4 mWorldTransform;
    // Flag to indicate the transform needs to be recalculated
    bool mRecomputeWorldTransform;

    // List of all components attached to this actor
    std::vector<class Component*> mComponents;
    class Game* mGame; // Owning game instance
};
```

### Step 6.2: Implement Actor Class

`src/Actor.cpp` implements the core logic for updating actors and their components.

```cpp
#include "Actor.hpp"
#include "Game.hpp"
#include "Component.hpp"
#include <algorithm>

Actor::Actor(Game* game)
    : mState(EActive), mPosition(Vector3::Zero), mScale(1.0f),
      mRotation(Quaternion::Identity), mGame(game),
      mRecomputeWorldTransform(true) {
    // Add this actor to the game's list of actors
    mGame->AddActor(this);
}

Actor::~Actor() {
    // Remove this actor from the game
    mGame->RemoveActor(this);
    // Clean up all components
    while (!mComponents.empty()) {
        delete mComponents.back();
    }
}

void Actor::Update(float deltaTime) {
    if (mState == EActive) {
        // Recompute world transform if needed
        ComputeWorldTransform();
        // Update all components
        UpdateComponents(deltaTime);
        // Run actor-specific update
        UpdateActor(deltaTime);
        // Recompute again in case the actor moved
        ComputeWorldTransform();
    }
}

void Actor::AddComponent(Component* component) {
    // Insert the component into the list in the correct update order
    int myOrder = component->GetUpdateOrder();
    auto iter = mComponents.begin();
    for (; iter != mComponents.end(); ++iter) {
        if (myOrder < (*iter)->GetUpdateOrder()) {
            break;
        }
    }
    mComponents.insert(iter, component);
}

void Actor::ComputeWorldTransform() {
    if (mRecomputeWorldTransform) {
        mRecomputeWorldTransform = false;
        // Build the world transform matrix from scale, rotation, and position
        mWorldTransform = Matrix4::CreateScale(mScale);
        mWorldTransform *= Matrix4::CreateFromQuaternion(mRotation);
        mWorldTransform *= Matrix4::CreateTranslation(mPosition);

        // Inform components that the world transform has updated
        for (auto comp : mComponents) {
            comp->OnUpdateWorldTransform();
        }
    }
}
// ... other function implementations ...
```

### Step 6.3: Create Base Component Class

`include/Component.hpp` is the base class for all components. It's very simple, defining the basic interface and storing a pointer to its owner actor.

```cpp
#pragma once
#include <cstdint>

class Component {
public:
    // The updateOrder determines the order of execution for components.
    // Lower numbers update first.
    Component(class Actor* owner, int updateOrder = 100);
    virtual ~Component();

    // Virtual functions to be overridden by subclasses
    virtual void Update(float deltaTime) {}
    virtual void ProcessInput(const uint8_t* keyState) {}
    virtual void OnUpdateWorldTransform() {}

    int GetUpdateOrder() const { return mUpdateOrder; }

protected:
    class Actor* mOwner;
    int mUpdateOrder;
};
```

---

## 7. Mesh Loading and Rendering

To render 3D objects, we need to load their vertex data (the triangles that make up the model) onto the GPU.

### Step 7.1: Create Vertex Array Class

The `VertexArray` class encapsulates the OpenGL objects needed to render a mesh: the Vertex Array Object (VAO), Vertex Buffer Object (VBO), and Index Buffer Object (IBO).

`include/VertexArray.hpp`:
```cpp
#pragma once
#include <GL/glew.h>

class VertexArray {
public:
    // Takes in vertex and index data to buffer to the GPU
    VertexArray(const float* verts, unsigned int numVerts,
               const unsigned int* indices, unsigned int numIndices);
    ~VertexArray();

    // Activates this vertex array for drawing
    void SetActive();

    unsigned int GetNumIndices() const { return mNumIndices; }
    unsigned int GetNumVerts() const { return mNumVerts; }

private:
    unsigned int mNumVerts;
    unsigned int mNumIndices;
    
    // OpenGL object IDs
    unsigned int mVertexBuffer; // VBO
    unsigned int mIndexBuffer;  // IBO
    unsigned int mVertexArray;  // VAO
};
```

### Step 7.2: Create Mesh Class

The `Mesh` class holds the `VertexArray` and material properties for a model, like its textures and shader.

`include/Mesh.hpp`:
```cpp
#pragma once
#include <vector>
#include <string>
#include "Math.hpp"

class Mesh {
public:
    Mesh();
    ~Mesh();

    // Load mesh data from a file (e.g., our custom .gpmesh format)
    bool Load(const std::string& fileName, class Renderer* renderer);
    void Unload();

    class VertexArray* GetVertexArray() { return mVertexArray; }
    class Texture* GetTexture(size_t index);
    const std::string& GetShaderName() const { return mShaderName; }
    float GetRadius() const { return mRadius; } // For collision detection
    float GetSpecPower() const { return mSpecPower; } // For lighting

private:
    std::vector<class Texture*> mTextures;
    class VertexArray* mVertexArray;
    std::string mShaderName;
    float mRadius;
    float mSpecPower;
};
```

### Step 7.3: Create Mesh Component

The `MeshComponent` is the bridge between an `Actor` and a `Mesh`. Attaching a `MeshComponent` to an actor makes it renderable.

`include/MeshComponent.hpp`:
```cpp
#pragma once
#include "Component.hpp"
#include <cstddef>

class MeshComponent : public Component {
public:
    MeshComponent(class Actor* owner);
    ~MeshComponent();

    // Draw this mesh using the provided shader
    virtual void Draw(class Shader* shader);
    
    virtual void SetMesh(class Mesh* mesh) { mMesh = mesh; }
    void SetTextureIndex(size_t index) { mTextureIndex = index; }

protected:
    class Mesh* mMesh;
    size_t mTextureIndex;
};
```

### Step 7.4: Implement Mesh Component

The `Draw` function is the most important part. It sets the shader uniforms and issues the OpenGL draw call.

`src/MeshComponent.cpp`:
```cpp
#include "MeshComponent.hpp"
#include "Shader.hpp"
#include "Mesh.hpp"
#include "Actor.hpp"
#include "Game.hpp"
#include "Renderer.hpp"
#include "Texture.hpp"
#include "VertexArray.hpp"

MeshComponent::MeshComponent(Actor* owner)
    : Component(owner), mMesh(nullptr), mTextureIndex(0) {
    // Add this component to the renderer's list of mesh components
    mOwner->GetGame()->GetRenderer()->AddMeshComp(this);
}

MeshComponent::~MeshComponent() {
    mOwner->GetGame()->GetRenderer()->RemoveMeshComp(this);
}

void MeshComponent::Draw(Shader* shader) {
    if (mMesh) {
        // Set the world transform uniform from the owner actor
        shader->SetMatrixUniform("uWorldTransform", mOwner->GetWorldTransform());
        // Set material properties
        shader->SetFloatUniform("uSpecPower", mMesh->GetSpecPower());
        
        // Set the active texture
        Texture* t = mMesh->GetTexture(mTextureIndex);
        if (t) {
            t->SetActive();
        }
        
        // Activate the mesh's vertex array
        VertexArray* va = mMesh->GetVertexArray();
        va->SetActive();
        
        // Issue the draw call
        glDrawElements(GL_TRIANGLES, va->GetNumIndices(), GL_UNSIGNED_INT, nullptr);
    }
}
```

---

## 8. Lighting System

To make our 3D scene look more realistic, we'll implement the Phong reflection model, which simulates ambient, diffuse, and specular lighting.

### Step 8.1: Create Phong Shaders

We'll create a new pair of shaders for lit meshes. The vertex shader is identical to `BasicMesh.vert`.

`shaders/Phong.vert`:
```glsl
#version 330
// ... (identical to BasicMesh.vert) ...
```

`shaders/Phong.frag`: This fragment shader calculates the final color based on the Phong lighting model.

```glsl
#version 330

// Inputs from vertex shader
in vec2 fragTexCoord;
in vec3 fragNormal;
in vec3 fragWorldPos;

// Final output color
out vec4 outColor;

// --- Uniforms ---
// Lighting
uniform vec3 uCameraPos;
uniform vec3 uAmbientLight;
// Directional light properties (nested in a struct)
uniform struct {
    vec3 mDirection;
    vec3 mDiffuseColor;
    vec3 mSpecColor;
} uDirLight;
// Material
uniform float uSpecPower;
uniform sampler2D uTexture;

void main() {
    // --- Vector Calculations ---
    // Normalize the surface normal
    vec3 N = normalize(fragNormal);
    // Vector from the surface point to the light source
    vec3 L = normalize(-uDirLight.mDirection);
    // Vector from the surface point to the camera
    vec3 V = normalize(uCameraPos - fragWorldPos);
    // Reflection of the light vector across the normal
    vec3 R = normalize(reflect(-L, N));

    // --- Phong Reflection Model ---
    // 1. Ambient term: a base light level
    vec3 Phong = uAmbientLight;
    
    // 2. Diffuse term: simulates directional light scattering
    float NdotL = dot(N, L);
    if (NdotL > 0) { // Only light surfaces facing the light
        vec3 Diffuse = uDirLight.mDiffuseColor * NdotL;
        
        // 3. Specular term: simulates shiny highlights
        float RdotV = max(0.0, dot(R, V));
        vec3 Specular = uDirLight.mSpecColor * pow(RdotV, uSpecPower);
        
        Phong += Diffuse + Specular;
    }

    // Final color is the texture color modulated by the calculated light
    outColor = texture(uTexture, fragTexCoord) * vec4(Phong, 1.0f);
}
```

### Step 8.2: Implement Lighting in Renderer

We need to pass the lighting data from our C++ code to the shader uniforms.

Add to `src/Renderer.cpp`:
```cpp
void Renderer::SetLightUniforms(Shader* shader) {
    // The camera position is the translation component of the inverse view matrix
    Matrix4 invView = mView;
    invView.Invert();
    shader->SetVectorUniform("uCameraPos", invView.GetTranslation());
    
    // Set ambient light
    shader->SetVectorUniform("uAmbientLight", mAmbientLight);
    
    // Set directional light properties
    shader->SetVectorUniform("uDirLight.mDirection", mDirLight.mDirection);
    shader->SetVectorUniform("uDirLight.mDiffuseColor", mDirLight.mDiffuseColor);
    shader->SetVectorUniform("uDirLight.mSpecColor", mDirLight.mSpecColor);
}
```

---

## 9. Camera and Movement

A camera is just an actor that we use to generate the view matrix. By moving this actor, we move the camera.

### Step 9.1: Create Camera Actor

`include/CameraActor.hpp` defines a simple actor that will serve as our camera.

```cpp
#pragma once
#include "Actor.hpp"

class CameraActor : public Actor {
public:
    CameraActor(class Game* game);

    void UpdateActor(float deltaTime) override;
    void ActorInput(const uint8_t* keys) override;

private:
    class MoveComponent* mMoveComp;
};
```

### Step 9.2: Implement Camera Actor

In `src/CameraActor.cpp`, we update the renderer's view matrix every frame based on the camera's position and orientation.

```cpp
#include "CameraActor.hpp"
#include "MoveComponent.hpp"
#include "Game.hpp"
#include "Renderer.hpp"
#include "SDL_scancode.h"

CameraActor::CameraActor(Game* game) : Actor(game) {
    // Give the camera a move component
    mMoveComp = new MoveComponent(this);
}

void CameraActor::UpdateActor(float deltaTime) {
    Actor::UpdateActor(deltaTime);

    // Create the view matrix using the "Look-At" function
    Vector3 cameraPos = GetPosition();
    // The target is a point 100 units in front of the camera
    Vector3 target = GetPosition() + GetForward() * 100.0f;
    // The "up" vector is along the world's Z-axis
    Vector3 up = Vector3::UnitZ;

    Matrix4 view = Matrix4::CreateLookAt(cameraPos, target, up);
    // Tell the renderer to use this new view matrix
    GetGame()->GetRenderer()->SetViewMatrix(view);
}

void CameraActor::ActorInput(const uint8_t* keys) {
    float forwardSpeed = 0.0f;
    float angularSpeed = 0.0f;

    // Simple WASD controls for movement
    if (keys[SDL_SCANCODE_W]) { forwardSpeed += 300.0f; }
    if (keys[SDL_SCANCODE_S]) { forwardSpeed -= 300.0f; }
    if (keys[SDL_SCANCODE_A]) { angularSpeed -= Math::TwoPi; }
    if (keys[SDL_SCANCODE_D]) { angularSpeed += Math::TwoPi; }

    mMoveComp->SetForwardSpeed(forwardSpeed);
    mMoveComp->SetAngularSpeed(angularSpeed);
}
```

### Step 9.3: Create Move Component

The `MoveComponent` encapsulates the logic for movement, which can be reused by any actor.

`include/MoveComponent.hpp`:
```cpp
#pragma once
#include "Component.hpp"

class MoveComponent : public Component {
public:
    // Lower update order to ensure movement happens before other logic
    MoveComponent(class Actor* owner, int updateOrder = 10);

    void Update(float deltaTime) override;

    // Getters and setters for speeds
    float GetAngularSpeed() const { return mAngularSpeed; }
    float GetForwardSpeed() const { return mForwardSpeed; }
    void SetAngularSpeed(float speed) { mAngularSpeed = speed; }
    void SetForwardSpeed(float speed) { mForwardSpeed = speed; }

private:
    float mAngularSpeed; // In radians/second
    float mForwardSpeed; // In units/second
};
```

### Step 9.4: Implement Move Component

`src/MoveComponent.cpp` updates the owner actor's position and rotation based on its speeds.

```cpp
#include "MoveComponent.hpp"
#include "Actor.hpp"
#include "Math.hpp" // For NearZero

MoveComponent::MoveComponent(Actor* owner, int updateOrder)
    : Component(owner, updateOrder), mAngularSpeed(0.0f), mForwardSpeed(0.0f) {}

void MoveComponent::Update(float deltaTime) {
    // Update rotation
    if (!Math::NearZero(mAngularSpeed)) {
        Quaternion rot = mOwner->GetRotation();
        float angle = mAngularSpeed * deltaTime;
        // Create a quaternion for rotation about the Z-axis
        Quaternion inc(Vector3::UnitZ, angle);
        // Concatenate to combine rotations
        rot = Quaternion::Concatenate(rot, inc);
        mOwner->SetRotation(rot);
    }

    // Update position
    if (!Math::NearZero(mForwardSpeed)) {
        Vector3 pos = mOwner->GetPosition();
        // Move along the actor's forward vector
        pos += mOwner->GetForward() * mForwardSpeed * deltaTime;
        mOwner->SetPosition(pos);
    }
}
```

---

## 10. Input Handling

We need to poll for keyboard state and pass it to our actors.

### Step 10.1: Implement Game Input Processing

This function in `src/Game.cpp` handles window events and keyboard state.

```cpp
void Game::ProcessInput() {
    SDL_Event event;
    // Poll for window events (like closing the window)
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
        case SDL_QUIT:
            mIsRunning = false;
            break;
        }
    }

    // Get the current state of the keyboard
    const Uint8* keyboardState = SDL_GetKeyboardState(NULL);
    // Exit on ESCAPE key
    if (keyboardState[SDL_SCANCODE_ESCAPE]) {
        mIsRunning = false;
    }

    // Pass the keyboard state to all actors for processing
    mUpdatingActors = true;
    for (auto actor : mActors) {
        actor->ProcessInput(keyboardState);
    }
    mUpdatingActors = false;
}
```

### Step 10.2: Create Input Component Base

For non-camera actors, we can create a more configurable `InputComponent`. This is left as an exercise but would allow setting keys and speeds for AI or player-controlled pawns.

`include/InputComponent.hpp`:
```cpp
#pragma once
#include "MoveComponent.hpp"

class InputComponent : public MoveComponent {
public:
    InputComponent(class Actor* owner);
    void ProcessInput(const uint8_t* keyState) override;

    // Getters/setters for keys and speeds...
private:
    float mMaxForwardSpeed;
    float mMaxAngularSpeed;
    int mForwardKey;
    int mBackKey;
    // ... and so on
};
```

---

## 11. Game Loop Integration

Now we tie everything together in the main game loop.

### Step 11.1: Implement Complete Game Loop

The full game loop implementation in `src/Game.cpp`.

```cpp
void Game::RunLoop() {
    while (mIsRunning) {
        ProcessInput();
        UpdateGame();
        GenerateOutput();
    }
}

void Game::UpdateGame() {
    // Simple frame rate limiting to ~60 FPS
    while (!SDL_TICKS_PASSED(SDL_GetTicks(), mTicksCount + 16));

    // Calculate delta time (time since last frame)
    float deltaTime = (SDL_GetTicks() - mTicksCount) / 1000.0f;
    // Clamp max delta time to prevent large jumps
    if (deltaTime > 0.05f) {
        deltaTime = 0.05f;
    }
    mTicksCount = SDL_GetTicks();

    // Update all actors
    mUpdatingActors = true;
    for (auto actor : mActors) {
        actor->Update(deltaTime);
    }
    mUpdatingActors = false;

    // Add any pending actors to the main actor list
    for (auto pending : mPendingActors) {
        pending->ComputeWorldTransform();
        mActors.emplace_back(pending);
    }
    mPendingActors.clear();

    // Remove and delete any dead actors
    std::vector<Actor*> deadActors;
    for (auto actor : mActors) {
        if (actor->GetState() == Actor::EDead) {
            deadActors.emplace_back(actor);
        }
    }
    for (auto actor : deadActors) {
        delete actor;
    }
}

void Game::GenerateOutput() {
    // This just calls the renderer's draw function
    mRenderer->Draw();
}
```

### Step 11.2: Complete Renderer Draw Function

The `Draw` function in `src/Renderer.cpp` sets up the graphics pipeline state and draws all the meshes and sprites.

```cpp
void Renderer::Draw() {
    // Clear the back buffer to a color
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    // Also clear the depth buffer
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // --- Draw 3D Meshes ---
    // Enable depth testing and disable blending
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_BLEND);
    
    // Activate the lit mesh shader
    mMeshShader->SetActive();
    // Set the view-projection matrix
    mMeshShader->SetMatrixUniform("uViewProj", mView * mProjection);
    // Set lighting uniforms
    SetLightUniforms(mMeshShader);
    
    // Draw all mesh components
    for (auto mc : mMeshComps) {
        mc->Draw(mMeshShader);
    }

    // --- Draw 2D Sprites (UI) ---
    // Disable depth testing and enable alpha blending
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // Activate the sprite shader
    mSpriteShader->SetActive();
    mSpriteVerts->SetActive();
    
    // Draw all sprite components
    for (auto sprite : mSprites) {
        sprite->Draw(mSpriteShader);
    }

    // Swap the front and back buffers to display the rendered scene
    SDL_GL_SwapWindow(mWindow);
}
```

### Step 11.3: Load Initial Game Data

In `src/Game.cpp`, we create the initial actors and set up the scene in `LoadData`.

```cpp
void Game::LoadData() {
    // Create a cube actor
    Actor* a = new Actor(this);
    a->SetPosition(Vector3(200.0f, 75.0f, 0.0f));
    a->SetScale(100.0f);
    MeshComponent* mc = new MeshComponent(a);
    mc->SetMesh(mRenderer->GetMesh("../assets/Cube.gpmesh"));

    // Create a sphere actor
    a = new Actor(this);
    a->SetPosition(Vector3(200.0f, -75.0f, 0.0f));
    a->SetScale(3.0f);
    mc = new MeshComponent(a);
    mc->SetMesh(mRenderer->GetMesh("../assets/Sphere.gpmesh"));

    // Set up lighting
    mRenderer->SetAmbientLight(Vector3(0.2f, 0.2f, 0.2f));
    DirectionalLight& dir = mRenderer->GetDirectionalLight();
    dir.mDirection = Vector3(0.0f, -0.707f, -0.707f);
    dir.mDiffuseColor = Vector3(0.78f, 0.88f, 1.0f);
    dir.mSpecColor = Vector3(0.8f, 0.8f, 0.8f);

    // Create the camera
    mCameraActor = new CameraActor(this);
}
```

---

## 12. Advanced Features

This guide provides the foundation. Here are some next steps to build a more feature-complete engine.

### Step 12.1: Sprite Rendering for UI
Create a `SpriteComponent` and corresponding shaders (`Sprite.vert`, `Sprite.frag`) to render 2D textures, which is perfect for UI elements like health bars, menus, and crosshairs. The key is to use an orthographic projection and disable depth testing.

### Step 12.2: Texture Loading
Implement a `Texture` class that uses a library like `stb_image` or `SDL_image` to load image files (e.g., PNG, JPG) from disk into an OpenGL texture object. The `Renderer` should cache these textures to avoid reloading them.

### Step 12.3: Audio System
Integrate an audio library like `SDL_mixer` or `FMOD`. Create an `AudioSystem` class to manage loading and playing sounds. You can then create an `AudioComponent` to attach sounds to actors, allowing for 3D positional audio.

### Step 12.4: Collision Detection
Implement a physics system. Start with simple bounding shapes like spheres or Axis-Aligned Bounding Boxes (AABBs). Add a `BoxComponent` or `SphereComponent` to actors and check for intersections every frame to detect collisions.

---

## Summary

This guide has walked through the essential steps to create a functional 3D game engine.

1.  **Project Setup**: Configured a clean project with CMake and essential libraries.
2.  **Window Creation**: Used SDL to create a window and an OpenGL 3.3 context.
3.  **Renderer**: Built a rendering pipeline to manage resources and draw scenes.
4.  **Shaders**: Created a system for loading and using GLSL shaders.
5.  **Math Library**: Implemented core 3D math constructs.
6.  **Actor-Component System**: Designed a flexible architecture for game objects.
7.  **Mesh System**: Loaded and rendered 3D models.
8.  **Lighting**: Implemented the Phong reflection model for realistic lighting.
9.  **Camera**: Created a movable first-person camera.
10. **Input**: Handled keyboard input for camera control and game events.
11. **Game Loop**: Integrated all systems into a robust main loop.
12. **Advanced Features**: Outlined next steps for UI, audio, and physics.

This engine provides a powerful and extensible foundation for building your own 3D games.
