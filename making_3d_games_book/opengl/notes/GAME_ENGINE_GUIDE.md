# Complete Step-by-Step 3D Game Engine Creation Guide

This guide documents the complete process of creating a 3D game engine from the ground up using C++, OpenGL for rendering, and SDL for windowing and input. The engine is designed with a modern, data-driven approach using an Actor/Component architecture and features a robust rendering pipeline with support for 3D meshes, lighting, and UI.

## Table of Contents
1. [Project Setup](#1-project-setup)
2. [Window Creation and OpenGL Context](#2-window-creation-and-opengl-context)
3. [Basic Renderer Setup](#3-basic-renderer-setup)
4. [Shader System](#4-shader-system)
5. [Math Library](#5-math-library)
6. [Actor and Component System](#6-actor-and-component-system)
7. [Mesh Loading and Rendering](#7-mesh-loading-and-rendering)
8. [Lighting System](#8-lighting-system)
9. [Camera and Movement](#9-camera-and-movement)
10. [Input Handling](#10-input-handling)
11. [Game Loop Integration](#11-game-loop-integration)
12. [UI and Sprite System](#12-ui-and-sprite-system)
13. [Asset Loading and File Formats](#13-asset-loading-and-file-formats)
14. [Advanced Features](#14-advanced-features)
15. [Collision Detection System](#15-collision-detection-system)
16. [Advanced Input System](#16-advanced-input-system)

---

## 1. Project Setup

Before writing any code, we need to set up a solid foundation for our project. This involves establishing a clean directory structure and configuring a build system.

### Dependencies Required
- **SDL2**: A cross-platform development library designed to provide low-level access to audio, keyboard, mouse, joystick, and graphics hardware via OpenGL and Direct3D. We will use it for window creation and input handling.
- **GLEW**: The OpenGL Extension Wrangler Library. It helps in querying and loading OpenGL extensions, which is essential for accessing functions in modern OpenGL versions (3.3+).
- **CMake**: A build system generator. It allows us to define our project structure and dependencies in a platform-agnostic way, generating native build files (like Makefiles or Visual Studio projects).

### Directory Structure
A well-organized directory structure is crucial for maintainability.

```
project/
├── CMakeLists.txt    # Build system configuration
├── include/          # Header files (.hpp) for our engine
├── src/              # Source files (.cpp)
├── shaders/          # GLSL shader files (.vert, .frag)
├── assets/           # Game assets (textures, meshes, sounds)
└── build/            # Build output (generated by CMake)
```

### CMakeLists.txt Setup
This file tells CMake how to build our project using modern practices with FetchContent for dependency management.

```cmake
# Require a modern version of CMake for FetchContent support
cmake_minimum_required(VERSION 3.29.3)

# Get project name from directory and define metadata
get_filename_component(PROJECT_NAME ${CMAKE_SOURCE_DIR} NAME)
project(${PROJECT_NAME} 
    VERSION 1.0.0
    DESCRIPTION "Modern C++ Game with SDL2, OpenGL"
    LANGUAGES CXX
)

# Enable compile_commands.json for LSP support
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Use modern C++23 standard for latest features
set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Build type configuration
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug)
endif()

# Gather all source files using CONFIGURE_DEPENDS for automatic updates
file(GLOB_RECURSE SOURCES CONFIGURE_DEPENDS
    ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp
    ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cxx
)

file(GLOB_RECURSE HEADERS CONFIGURE_DEPENDS
    ${CMAKE_CURRENT_SOURCE_DIR}/include/*.hpp
    ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h
)

# Create the executable target
add_executable(main ${SOURCES} ${HEADERS})

# Include directories
target_include_directories(main
    PRIVATE
        ${CMAKE_SOURCE_DIR}/include
        ${CMAKE_CURRENT_SOURCE_DIR}/include
)

# Use FetchContent to automatically download and build dependencies
include(FetchContent)

# SDL2 Main Library - fetch from official repository
FetchContent_Declare(SDL2
    GIT_REPOSITORY https://github.com/libsdl-org/SDL
    GIT_TAG        release-2.32.4
    GIT_SHALLOW    TRUE
)

# SDL2_image for texture loading
FetchContent_Declare(SDL2_image
    GIT_REPOSITORY https://github.com/libsdl-org/SDL_image
    GIT_TAG        release-2.8.8
    GIT_SHALLOW    TRUE
)

# STB for OpenGL texture loading (header-only library)
FetchContent_Declare(stb
  GIT_REPOSITORY https://github.com/nothings/stb
  GIT_TAG        master
)

# RapidJSON for JSON parsing (used for asset loading)
FetchContent_Declare(rapidjson
  GIT_REPOSITORY https://github.com/Tencent/rapidjson
  GIT_TAG        v1.1.0
  GIT_SHALLOW    TRUE
)

# Configure SDL2 options before making available
set(SDL_SHARED ON CACHE BOOL "Build SDL2 shared library")
set(SDL_STATIC OFF CACHE BOOL "Build SDL2 static library")

# Disable RapidJSON examples/tests to avoid compilation issues
set(RAPIDJSON_BUILD_DOC OFF CACHE BOOL "" FORCE)
set(RAPIDJSON_BUILD_EXAMPLES OFF CACHE BOOL "" FORCE)
set(RAPIDJSON_BUILD_TESTS OFF CACHE BOOL "" FORCE)

# Make all dependencies available
FetchContent_MakeAvailable(SDL2 SDL2_image stb rapidjson)

# Create interface library for stb_image
add_library(stb_image INTERFACE)
target_include_directories(stb_image INTERFACE ${stb_SOURCE_DIR})

# Add RapidJSON include directories
target_include_directories(main PRIVATE ${rapidjson_SOURCE_DIR}/include)

# Find system packages that aren't available via FetchContent
find_package(GLEW REQUIRED)
find_package(OpenGL REQUIRED)
find_package(Threads REQUIRED)

# Link all libraries to our target
target_link_libraries(main
PRIVATE
        SDL2::SDL2
        SDL2::SDL2main
        SDL2_image::SDL2_image
        GLEW::GLEW
        OpenGL::GL
        Threads::Threads
        stb_image
)
```

---

## 2. Window Creation and OpenGL Context

The first step in our code is to get a window to appear on the screen. The `Game` class will be the central hub of our engine, managing the main loop and all game objects.

### Step 2.1: Create the Main Game Class

`include/Game.hpp` defines the interface for our `Game` class.

```cpp
#pragma once
#include <SDL2/SDL.h>
#include <vector>

// Forward-declare classes to avoid circular dependencies
class Actor;
class Renderer;
class CameraActor;

class Game {
public:
    // Define screen dimensions as constants
    static constexpr float SCREEN_WIDTH = 1024.0f;
    static constexpr float SCREEN_HEIGHT = 768.0f;

    Game();
    bool Initialize(); // Initializes the game and all subsystems
    void RunLoop();    // Runs the main game loop until the game is over
    void Shutdown();   // Shuts down all subsystems and cleans up memory

    // Actor management
    void AddActor(Actor* actor);
    void RemoveActor(Actor* actor);

    // Getters
    class Renderer* GetRenderer() { return mRenderer; }

private:
    // Core game loop functions
    void ProcessInput(); // Process user input
    void UpdateGame();   // Update game state
    void GenerateOutput(); // Render the scene

    // Data loading
    void LoadData();
    void UnloadData();

    // All actors in the game world
    std::vector<Actor*> mActors;
    // Actors waiting to be added to the world
    std::vector<Actor*> mPendingActors;
    
    // The main renderer
    class Renderer* mRenderer;
    // Track elapsed time
    Uint32 mTicksCount;
    // Game loop flag
    bool mIsRunning;
    // Flag to prevent modifying actor list while iterating
    bool mUpdatingActors;
    
    // The player's camera
    CameraActor* mCameraActor;
};
```

### Step 2.2: Implement Game Initialization

`src/Game.cpp` contains the implementation. Here, we initialize SDL and create our `Renderer`, which will in turn create the OpenGL context.

```cpp
#include "Game.hpp"
#include "Renderer.hpp"
#include "SDL_log.h"
#include "SDL_timer.h"

Game::Game() : mRenderer{nullptr}, mIsRunning{true}, mUpdatingActors{false} {}

bool Game::Initialize() {
    // Try to initialize SDL with video and audio support
    int sdlResult = SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO);
    if (sdlResult != 0) {
        SDL_Log("Failed to initialize with audio: %s", SDL_GetError());
        // If audio fails, fall back to video only
        sdlResult = SDL_Init(SDL_INIT_VIDEO);
        if (sdlResult != 0) {
            SDL_Log("Unable to initialize SDL: %s", SDL_GetError());
            return false;
        }
    }

    // Create the renderer, which will create the window and OpenGL context
    mRenderer = new Renderer(this);
    if (!mRenderer->Initialize(SCREEN_WIDTH, SCREEN_HEIGHT)) {
        SDL_Log("Failed to initialize renderer");
        delete mRenderer;
        mRenderer = nullptr;
        return false;
    }

    // Load initial game data (actors, etc.)
    LoadData();
    // Initialize the tick counter for delta time calculation
    mTicksCount = SDL_GetTicks();
    return true;
}
```

### Step 2.3: Main Entry Point

`src/main.cpp` is the entry point of our application. It creates a `Game` instance and runs it.

```cpp
#include "Game.hpp"

int main() {
    Game game;
    bool success = game.Initialize();

    if (success) {
        game.RunLoop();
    }

    game.Shutdown();
    return 0;
}
```

---

## 3. Basic Renderer Setup

The `Renderer` class is responsible for all drawing. It manages the SDL window, the OpenGL context, and all rendering resources like shaders and meshes.

### Step 3.1: Create Renderer Class

`include/Renderer.hpp` defines the `Renderer`'s interface.

```cpp
#pragma once
#include "Math.hpp"
#include "SDL_video.h"
#include <string>
#include <unordered_map>
#include <vector>

// A simple struct for a directional light source
struct DirectionalLight {
    Vector3 mDirection;    // Direction of the light
    Vector3 mDiffuseColor; // Color of the diffuse light
    Vector3 mSpecColor;    // Color of the specular highlight
};

class Renderer {
public:
    Renderer(class Game* game);
    ~Renderer();

    bool Initialize(float screenWidth, float screenHeight);
    void Shutdown();
    void Draw(); // Draw the entire scene

    // Component management
    void AddSprite(class SpriteComponent* sprite);
    void RemoveSprite(class SpriteComponent* sprite);
    void AddMeshComp(class MeshComponent* mesh);
    void RemoveMeshComp(class MeshComponent* mesh);

    // Resource management
    class Texture* GetTexture(const std::string& fileName);
    class Mesh* GetMesh(const std::string& fileName);

    // Setters for view matrix and lighting
    void SetViewMatrix(const Matrix4& view) { mView = view; }
    void SetAmbientLight(const Vector3& ambient) { mAmbientLight = ambient; }
    DirectionalLight& GetDirectionalLight() { return mDirLight; }

    // Getters
    float GetScreenWidth() const { return mScreenWidth; }
    float GetScreenHeight() const { return mScreenHeight; }

private:
    bool LoadShaders();
    void CreateSpriteVerts();
    void SetLightUniforms(class Shader* shader);

    // Resource caches
    std::unordered_map<std::string, class Texture*> mTextures;
    std::unordered_map<std::string, class Mesh*> mMeshes;

    // Lists of components to draw
    std::vector<class SpriteComponent*> mSprites; // For UI
    std::vector<class MeshComponent*> mMeshComps; // For 3D objects

    class Game* mGame;
    class Shader* mSpriteShader;
    class Shader* mMeshShader;
    class VertexArray* mSpriteVerts; // Vertex data for drawing all sprites

    // Matrices for 3D rendering
    Matrix4 mView;       // View matrix (camera)
    Matrix4 mProjection; // Projection matrix (perspective)
    float mScreenWidth;
    float mScreenHeight;

    // Lighting data
    Vector3 mAmbientLight;
    DirectionalLight mDirLight;

    // SDL/OpenGL handles
    SDL_Window* mWindow;
    SDL_GLContext mContext;
};
```

### Step 3.2: Implement Renderer Initialization

In `src/Renderer.cpp`, we configure and create the OpenGL 3.3 Core Profile context.

```cpp
#include "Renderer.hpp"
#include "Shader.hpp"
#include "VertexArray.hpp"
#include "Texture.hpp"
#include "Mesh.hpp"
#include <GL/glew.h>
#include <SDL_log.h>

bool Renderer::Initialize(float screenWidth, float screenHeight) {
    mScreenWidth = screenWidth;
    mScreenHeight = screenHeight;

    // Configure OpenGL attributes before creating the context
    // Use OpenGL 3.3 Core Profile
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    // Request 8-bits per color channel
    SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
    SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
    // Request a 24-bit depth buffer
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    // Enable double buffering
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    // Use hardware acceleration
    SDL_GL_SetAttribute(SDL_GL_ACCELERATED_VISUAL, 1);

    // Create the SDL window
    mWindow = SDL_CreateWindow("3D Game Engine", 100, 100,
                              static_cast<int>(mScreenWidth),
                              static_cast<int>(mScreenHeight),
                              SDL_WINDOW_OPENGL);
    if (!mWindow) {
        SDL_Log("Failed to create window: %s", SDL_GetError());
        return false;
    }

    // Create the OpenGL context
    mContext = SDL_GL_CreateContext(mWindow);

    // Initialize GLEW to load OpenGL extensions
    glewExperimental = GL_TRUE;
    if (glewInit() != GLEW_OK) {
        SDL_Log("Failed to initialize GLEW.");
        return false;
    }
    // On some platforms, glewInit can generate a benign error code, so clear it.
    glGetError();

    // Now that we have a context, we can load our shaders
    if (!LoadShaders()) {
        SDL_Log("Failed to load shaders.");
        return false;
    }

    // Create a default vertex array for rendering sprites
    CreateSpriteVerts();

    return true;
}
```

---

## 4. Shader System

Shaders are small programs that run on the GPU and are essential for modern rendering. We'll need a vertex shader (to position vertices) and a fragment shader (to color pixels).

### Step 4.1: Create Shader Class

`include/Shader.hpp` provides an interface to load, unload, and activate a shader program.

```cpp
#pragma once
#include <GL/glew.h>
#include <string>
#include "Math.hpp"

class Shader {
public:
    Shader();
    ~Shader();

    // Load vertex and fragment shaders from file and compile them into a program
    bool Load(const std::string& vertName, const std::string& fragName);
    void Unload();
    
    // Set this as the active shader program
    void SetActive();

    // Functions to set uniform variables in the shader
    void SetMatrixUniform(const char* name, const Matrix4& matrix);
    void SetVectorUniform(const char* name, const Vector3& vector);
    void SetFloatUniform(const char* name, float value);

private:
    // Helper functions to compile a single shader and validate the program
    bool CompileShader(const std::string& fileName, GLenum shaderType, GLuint& outShader);
    bool IsCompiled(GLuint shader);
    bool IsValidProgram();

    // OpenGL IDs for the shaders and program
    GLuint mVertexShader;
    GLuint mFragShader;
    GLuint mShaderProgram;
};
```

### Step 4.2: Implement Shader Loading

`src/Shader.cpp` handles the file I/O and OpenGL calls to create a shader program.

```cpp
#include "Shader.hpp"
#include <SDL_log.h>
#include <fstream>
#include <sstream>

bool Shader::Load(const std::string& vertName, const std::string& fragName) {
    // Compile the vertex and fragment shaders
    if (!CompileShader(vertName, GL_VERTEX_SHADER, mVertexShader) ||
        !CompileShader(fragName, GL_FRAGMENT_SHADER, mFragShader)) {
        return false;
    }

    // Create the shader program and attach the shaders
    mShaderProgram = glCreateProgram();
    glAttachShader(mShaderProgram, mVertexShader);
    glAttachShader(mShaderProgram, mFragShader);
    // Link the program to generate the executable
    glLinkProgram(mShaderProgram);

    // Verify that the program linked successfully
    if (!IsValidProgram()) {
        return false;
    }

    return true;
}

bool Shader::CompileShader(const std::string& fileName, GLenum shaderType, GLuint& outShader) {
    std::ifstream shaderFile(fileName);
    if (shaderFile.is_open()) {
        // Read the entire file into a string
        std::stringstream sstream;
        sstream << shaderFile.rdbuf();
        std::string contents = sstream.str();
        const char* contentsChar = contents.c_str();

        // Create the shader object
        outShader = glCreateShader(shaderType);
        // Provide the source code
        glShaderSource(outShader, 1, &(contentsChar), nullptr);
        // Compile the shader
        glCompileShader(outShader);

        // Check for compilation errors
        if (!IsCompiled(outShader)) {
            SDL_Log("Failed to compile shader %s", fileName.c_str());
            return false;
        }
    } else {
        SDL_Log("Shader file not found: %s", fileName.c_c_str());
        return false;
    }

    return true;
}
```

### Step 4.3: Create Phong Lighting Shaders

Our engine uses Phong lighting shaders directly for realistic rendering. These are the actual shader programs written in GLSL (OpenGL Shading Language).

`shaders/Phong.vert`: This vertex shader transforms vertex positions from model space to clip space and passes data like normals and texture coordinates to the fragment shader.

```glsl
#version 330

// Input vertex attributes
layout(location = 0) in vec3 inPosition; // Vertex position in model space
layout(location = 1) in vec3 inNormal;   // Vertex normal in model space
layout(location = 2) in vec2 inTexCoord; // Texture coordinate

// Uniforms (global variables) passed from C++
uniform mat4 uWorldTransform; // Model to world space matrix
uniform mat4 uViewProj;       // Combined view-projection matrix

// Outputs passed to the fragment shader (interpolated across the triangle)
out vec2 fragTexCoord;
out vec3 fragNormal;
out vec3 fragWorldPos;

void main() {
    // Transform position to world space
    vec4 pos = vec4(inPosition, 1.0);
    pos = pos * uWorldTransform;
    fragWorldPos = pos.xyz; // Save world position for lighting

    // Transform position to clip space
    gl_Position = pos * uViewProj;
    
    // Transform normal to world space (as a direction)
    fragNormal = (vec4(inNormal, 0.0f) * uWorldTransform).xyz;
    // Pass through texture coordinate
    fragTexCoord = inTexCoord;
}
```

`shaders/Phong.frag`: This fragment shader implements the complete Phong lighting model with ambient, diffuse, and specular components.

```glsl
#version 330

// Inputs from vertex shader
in vec2 fragTexCoord;
in vec3 fragNormal;
in vec3 fragWorldPos;

// Output color for the pixel
out vec4 outColor;

// Texture sampling
uniform sampler2D uTexture;

// Create a struct for directional light
struct DirectionalLight
{
    vec3 mDirection;    // Direction of light
    vec3 mDiffuseColor; // Diffuse color
    vec3 mSpecColor;    // Specular color
};

// Uniforms for lighting
uniform vec3 uCameraPos;        // Camera position (in world space)
uniform float uSpecPower;       // Specular power for this surface
uniform vec3 uAmbientLight;     // Ambient light level
uniform DirectionalLight uDirLight; // Directional light

void main()
{
    // Surface normal
    vec3 N = normalize(fragNormal);
    // Vector from surface to light
    vec3 L = normalize(-uDirLight.mDirection);
    // Vector from surface to camera
    vec3 V = normalize(uCameraPos - fragWorldPos);
    // Reflection of -L about N
    vec3 R = normalize(reflect(-L, N));

    // Compute Phong reflection model
    vec3 Phong = uAmbientLight;
    float NdotL = dot(N, L);
    if (NdotL > 0)
    {
        vec3 Diffuse = uDirLight.mDiffuseColor * NdotL;
        vec3 Specular = uDirLight.mSpecColor * pow(max(0.0, dot(R, V)), uSpecPower);
        Phong += Diffuse + Specular;
    }

    // Final color is texture color modulated by calculated lighting
    outColor = texture(uTexture, fragTexCoord) * vec4(Phong, 1.0f);
}
```

---

## 5. Math Library

A solid math library is the backbone of any game engine. We need vectors, matrices, and quaternions.

### Step 5.1: Create Math Header

`include/Math.hpp` contains all our math structures and functions. For a real project, using a library like GLM is recommended, but creating our own is a great learning exercise.

```cpp
#pragma once
#include <cmath>
#include <limits>

// A namespace for common math constants and functions
namespace Math {
    const float Pi = 3.1415926535f;
    const float TwoPi = Pi * 2.0f;
    const float PiOver2 = Pi / 2.0f;
    const float Infinity = std::numeric_limits<float>::infinity();
    const float NegInfinity = -std::numeric_limits<float>::infinity();

    inline float ToRadians(float degrees) { return degrees * Pi / 180.0f; }
    inline float ToDegrees(float radians) { return radians * 180.0f / Pi; }
}

// A 3D vector
struct Vector3 {
    float x, y, z;
    // Constructors, operators, and utility functions...
};

// A quaternion for representing rotations
// Quaternions are used to avoid gimbal lock and for smooth interpolation
struct Quaternion {
    float x, y, z, w;
    // Constructors and utility functions...
};

// A 4x4 matrix for transformations
struct Matrix4 {
    float mat[4][4];
    // Constructors, operators, and utility functions...

    // Static functions to create specific transformation matrices
    static Matrix4 CreateScale(float xScale, float yScale, float zScale);
    static Matrix4 CreateRotationX(float theta);
    static Matrix4 CreateRotationY(float theta);
    static Matrix4 CreateRotationZ(float theta);
    static Matrix4 CreateFromQuaternion(const Quaternion& q);
    static Matrix4 CreateTranslation(const Vector3& trans);
    
    // Functions to create view and projection matrices
    static Matrix4 CreateLookAt(const Vector3& eye, const Vector3& target, const Vector3& up);
    static Matrix4 CreateOrtho(float width, float height, float near, float far);
    static Matrix4 CreatePerspectiveFOV(float fovY, float width, float height, float near, float far);

    static const Matrix4 Identity;
};
```

---

## 6. Actor and Component System

We use an Actor-Component model. **Actors** (or Entities) are the "things" in our game world (e.g., the player, an enemy, a wall). **Components** are reusable modules of data and functionality that we attach to Actors to give them behavior (e.g., a `RenderComponent` to make an actor visible, a `MoveComponent` to make it move).

### Step 6.1: Create Base Actor Class

`include/Actor.hpp` defines the `Actor` class, which is the base for all objects in our game.

```cpp
#pragma once
#include "Math.hpp"
#include <vector>
#include <cstdint>

class Actor {
public:
    // Actors can be in one of three states
    enum State {
        EActive,
        EPaused,
        EDead
    };

    Actor(class Game* game);
    virtual ~Actor();

    // Main update function, called once per frame
    void Update(float deltaTime);
    // Updates all components attached to this actor
    void UpdateComponents(float deltaTime);
    // Actor-specific update logic (can be overridden by subclasses)
    virtual void UpdateActor(float deltaTime);

    // Input processing
    void ProcessInput(const uint8_t* keyState);
    virtual void ActorInput(const uint8_t* keyState);

    // Getters and setters for transform
    const Vector3& GetPosition() const { return mPosition; }
    void SetPosition(const Vector3& pos) { mPosition = pos; mRecomputeWorldTransform = true; }
    float GetScale() const { return mScale; }
    void SetScale(float scale) { mScale = scale; mRecomputeWorldTransform = true; }
    const Quaternion& GetRotation() const { return mRotation; }
    void SetRotation(const Quaternion& rotation) { mRotation = rotation; mRecomputeWorldTransform = true; }

    // Utility functions
    Vector3 GetForward() const;
    State GetState() const { return mState; }
    void SetState(State state) { mState = state; }
    class Game* GetGame() { return mGame; }
    const Matrix4& GetWorldTransform() const { return mWorldTransform; }

    // Component management
    void AddComponent(class Component* component);
    void RemoveComponent(class Component* component);

private:
    // Recalculates the world transform matrix
    void ComputeWorldTransform();

    State mState;
    
    // Transform properties
    Vector3 mPosition;
    Quaternion mRotation;
    float mScale;

    // The final world transform matrix, sent to the shader
    Matrix4 mWorldTransform;
    // Flag to indicate the transform needs to be recalculated
    bool mRecomputeWorldTransform;

    // List of all components attached to this actor
    std::vector<class Component*> mComponents;
    class Game* mGame; // Owning game instance
};
```

### Step 6.2: Implement Actor Class

`src/Actor.cpp` implements the core logic for updating actors and their components.

```cpp
#include "Actor.hpp"
#include "Game.hpp"
#include "Component.hpp"
#include <algorithm>

Actor::Actor(Game* game)
    : mState(EActive), mPosition(Vector3::Zero), mScale(1.0f),
      mRotation(Quaternion::Identity), mGame(game),
      mRecomputeWorldTransform(true) {
    // Add this actor to the game's list of actors
    mGame->AddActor(this);
}

Actor::~Actor() {
    // Remove this actor from the game
    mGame->RemoveActor(this);
    // Clean up all components
    while (!mComponents.empty()) {
        delete mComponents.back();
    }
}

void Actor::Update(float deltaTime) {
    if (mState == EActive) {
        // Recompute world transform if needed
        ComputeWorldTransform();
        // Update all components
        UpdateComponents(deltaTime);
        // Run actor-specific update
        UpdateActor(deltaTime);
        // Recompute again in case the actor moved
        ComputeWorldTransform();
    }
}

void Actor::AddComponent(Component* component) {
    // Insert the component into the list in the correct update order
    int myOrder = component->GetUpdateOrder();
    auto iter = mComponents.begin();
    for (; iter != mComponents.end(); ++iter) {
        if (myOrder < (*iter)->GetUpdateOrder()) {
            break;
        }
    }
    mComponents.insert(iter, component);
}

void Actor::ComputeWorldTransform() {
    if (mRecomputeWorldTransform) {
        mRecomputeWorldTransform = false;
        // Build the world transform matrix from scale, rotation, and position
        mWorldTransform = Matrix4::CreateScale(mScale);
        mWorldTransform *= Matrix4::CreateFromQuaternion(mRotation);
        mWorldTransform *= Matrix4::CreateTranslation(mPosition);

        // Inform components that the world transform has updated
        for (auto comp : mComponents) {
            comp->OnUpdateWorldTransform();
        }
    }
}
// ... other function implementations ...
```

### Step 6.3: Create Specialized Actor Classes

Beyond the base `Actor` class, we often need specialized actors for specific purposes. A perfect example is the `PlaneActor`, which is used extensively for creating walls and floors in our 3D environments.

#### PlaneActor Implementation

`include/PlaneActor.hpp` defines a simple specialized actor:
```cpp
#pragma once
#include "Actor.hpp"

class PlaneActor : public Actor {
public:
    PlaneActor(class Game* game);
};
```

`src/PlaneActor.cpp` shows how specialized actors can set up their own components automatically:
```cpp
#include "PlaneActor.hpp"
#include "Game.hpp"
#include "MeshComponent.hpp"
#include "Renderer.hpp"

PlaneActor::PlaneActor(Game* game) : Actor(game) {
    // Automatically scale the plane to appropriate size
    SetScale(10.0f);
    
    // Automatically attach a mesh component with the plane mesh
    MeshComponent* mc = new MeshComponent(this);
    auto* mesh = GetGame()->GetRenderer()->GetMesh("../assets/Plane.gpmesh");
    mc->SetMesh(mesh);
}
```

This pattern allows us to create reusable actor types. When we need a floor tile or wall segment, we simply create a `PlaneActor` and position it appropriately, rather than manually setting up the mesh component each time.

### Step 6.4: Create Base Component Class

`include/Component.hpp` is the base class for all components. It's very simple, defining the basic interface and storing a pointer to its owner actor.

```cpp
#pragma once
#include <cstdint>

class Component {
public:
    // The updateOrder determines the order of execution for components.
    // Lower numbers update first.
    Component(class Actor* owner, int updateOrder = 100);
    virtual ~Component();

    // Virtual functions to be overridden by subclasses
    virtual void Update(float deltaTime) {}
    virtual void ProcessInput(const uint8_t* keyState) {}
    virtual void OnUpdateWorldTransform() {}

    int GetUpdateOrder() const { return mUpdateOrder; }

protected:
    class Actor* mOwner;
    int mUpdateOrder;
};
```

---

## 7. Mesh Loading and Rendering

To render 3D objects, we need to load their vertex data (the triangles that make up the model) onto the GPU.

### Step 7.1: Create Vertex Array Class

The `VertexArray` class encapsulates the OpenGL objects needed to render a mesh: the Vertex Array Object (VAO), Vertex Buffer Object (VBO), and Index Buffer Object (IBO).

`include/VertexArray.hpp`:
```cpp
#pragma once

/*
 Vertex Array: The concept of defining polygon vertices in an ordered list.

  Vertex Buffer (VBO): GPU memory that stores the actual vertex data (positions,
  colors, normals, texture coordinates).

  Index Buffer (EBO/IBO): GPU memory that stores indices pointing to vertices in
 the vertex buffer.

  How They Work Together:

  Without Index Buffer:
  // Vertex buffer for a quad (2 triangles)
  float vertices[] = {
      // Triangle 1
      -0.5f, -0.5f,  // vertex 0
       0.5f, -0.5f,  // vertex 1
       0.5f,  0.5f,  // vertex 2
      // Triangle 2
      -0.5f, -0.5f,  // vertex 0 (duplicate!)
       0.5f,  0.5f,  // vertex 2 (duplicate!)
      -0.5f,  0.5f   // vertex 3
  };

  With Index Buffer:
  // Vertex buffer (no duplicates)
  float vertices[] = {
      -0.5f, -0.5f,  // vertex 0
       0.5f, -0.5f,  // vertex 1
       0.5f,  0.5f,  // vertex 2
      -0.5f,  0.5f   // vertex 3
  };

  // Index buffer (references vertices)
  unsigned int indices[] = {
      0, 1, 2,  // Triangle 1
      0, 2, 3   // Triangle 2
  };

  Benefits:
  - Eliminates duplicate vertices
  - Saves memory
  - More efficient rendering
 */

class VertexArray {
public:
    VertexArray(const float* verts, unsigned int numVerts,
               const unsigned int* indices, unsigned int numIndices);
    ~VertexArray();

    void SetActive(); // Activate vertex array to draw

    unsigned int GetNumIndices() const noexcept { return mNumIndices; }
    unsigned int GetNumVerts() const noexcept { return mNumVerts; }

private:
    unsigned int mNumVerts;    // How many vertices in the vertex buffer?
    unsigned int mNumIndices;  // How many indices in the index buffer
    unsigned int mVertexBuffer; // OpenGL ID of the vertex buffer
    unsigned int mIndexBuffer;  // OpenGL ID of the index buffer
    unsigned int mVertexArray;  // OpenGL ID of the vertex array object
};
```

`src/VertexArray.cpp` handles the complex OpenGL setup:
```cpp
#include "VertexArray.hpp"
#include <GL/glew.h>

VertexArray::VertexArray(const float* verts, unsigned int numVerts,
                        const unsigned int* indices, unsigned int numIndices)
    : mNumVerts(numVerts), mNumIndices(numIndices) {
    
    // Create vertex array object (VAO) - stores all vertex attribute state
    glGenVertexArrays(1, &mVertexArray);
    glBindVertexArray(mVertexArray);

    // Create vertex buffer object (VBO) - stores vertex data on GPU
    glGenBuffers(1, &mVertexBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, mVertexBuffer);
    // Upload vertex data to GPU (8 floats per vertex: position(3) + normal(3) + texcoords(2))
    glBufferData(GL_ARRAY_BUFFER, numVerts * 8 * sizeof(float), verts, GL_STATIC_DRAW);

    // Create index buffer object (EBO) - stores triangle indices for indexed drawing
    glGenBuffers(1, &mIndexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mIndexBuffer);
    // Upload index data to GPU
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, numIndices * sizeof(unsigned int),
                 indices, GL_STATIC_DRAW);

    // Configure vertex attribute pointers to tell OpenGL how to interpret vertex data
    // Vertex format: [x, y, z, nx, ny, nz, u, v] (8 floats total per vertex)
    
    // Position attribute (location 0): 3 floats starting at offset 0
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), 0);

    // Normal attribute (location 1): 3 floats starting at offset 12 bytes (3 floats)
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float),
                          reinterpret_cast<void*>(sizeof(float) * 3));

    // Texture coordinates attribute (location 2): 2 floats starting at offset 24 bytes (6 floats)
    glEnableVertexAttribArray(2);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float),
                          reinterpret_cast<void*>(sizeof(float) * 6));
}

VertexArray::~VertexArray() {
    // Clean up OpenGL resources
    glDeleteBuffers(1, &mVertexBuffer);
    glDeleteBuffers(1, &mIndexBuffer);
    glDeleteVertexArrays(1, &mVertexArray);
}

void VertexArray::SetActive() { 
    // Bind this VAO to make it the active vertex array for rendering
    glBindVertexArray(mVertexArray); 
}
```

### Step 7.2: Create Mesh Class

The `Mesh` class holds the `VertexArray` and material properties for a model, like its textures and shader.

`include/Mesh.hpp`:
```cpp
#pragma once
#include <vector>
#include <string>
#include "Math.hpp"

class Mesh {
public:
    Mesh();
    ~Mesh();

    // Load mesh data from a file (e.g., our custom .gpmesh format)
    bool Load(const std::string& fileName, class Renderer* renderer);
    void Unload();

    class VertexArray* GetVertexArray() { return mVertexArray; }
    class Texture* GetTexture(size_t index);
    const std::string& GetShaderName() const { return mShaderName; }
    float GetRadius() const { return mRadius; } // For collision detection
    float GetSpecPower() const { return mSpecPower; } // For lighting

private:
    std::vector<class Texture*> mTextures;
    class VertexArray* mVertexArray;
    std::string mShaderName;
    float mRadius;
    float mSpecPower;
};
```

### Step 7.3: Create Mesh Component

The `MeshComponent` is the bridge between an `Actor` and a `Mesh`. Attaching a `MeshComponent` to an actor makes it renderable.

`include/MeshComponent.hpp`:
```cpp
#pragma once
#include "Component.hpp"
#include <cstddef>

class MeshComponent : public Component {
public:
    MeshComponent(class Actor* owner);
    ~MeshComponent();

    // Draw this mesh using the provided shader
    virtual void Draw(class Shader* shader);
    
    virtual void SetMesh(class Mesh* mesh) { mMesh = mesh; }
    void SetTextureIndex(size_t index) { mTextureIndex = index; }

protected:
    class Mesh* mMesh;
    size_t mTextureIndex;
};
```

### Step 7.4: Implement Mesh Component

The `Draw` function is the most important part. It sets the shader uniforms and issues the OpenGL draw call.

`src/MeshComponent.cpp`:
```cpp
#include "MeshComponent.hpp"
#include "Shader.hpp"
#include "Mesh.hpp"
#include "Actor.hpp"
#include "Game.hpp"
#include "Renderer.hpp"
#include "Texture.hpp"
#include "VertexArray.hpp"

MeshComponent::MeshComponent(Actor* owner)
    : Component(owner), mMesh(nullptr), mTextureIndex(0) {
    // Add this component to the renderer's list of mesh components
    mOwner->GetGame()->GetRenderer()->AddMeshComp(this);
}

MeshComponent::~MeshComponent() {
    mOwner->GetGame()->GetRenderer()->RemoveMeshComp(this);
}

void MeshComponent::Draw(Shader* shader) {
    if (mMesh) {
        // Set the world transform uniform from the owner actor
        shader->SetMatrixUniform("uWorldTransform", mOwner->GetWorldTransform());
        // Set material properties
        shader->SetFloatUniform("uSpecPower", mMesh->GetSpecPower());
        
        // Set the active texture
        Texture* t = mMesh->GetTexture(mTextureIndex);
        if (t) {
            t->SetActive();
        }
        
        // Activate the mesh's vertex array
        VertexArray* va = mMesh->GetVertexArray();
        va->SetActive();
        
        // Issue the draw call
        glDrawElements(GL_TRIANGLES, va->GetNumIndices(), GL_UNSIGNED_INT, nullptr);
    }
}
```

---

## 8. Lighting System

To make our 3D scene look more realistic, we'll implement the Phong reflection model, which simulates ambient, diffuse, and specular lighting.

### Step 8.1: Create Phong Shaders

We'll create a new pair of shaders for lit meshes. The vertex shader is identical to `BasicMesh.vert`.

`shaders/Phong.vert`:
```glsl
#version 330
// ... (identical to BasicMesh.vert) ...
```

`shaders/Phong.frag`: This fragment shader calculates the final color based on the Phong lighting model.

```glsl
#version 330

// Inputs from vertex shader
in vec2 fragTexCoord;
in vec3 fragNormal;
in vec3 fragWorldPos;

// Final output color
out vec4 outColor;

// --- Uniforms ---
// Lighting
uniform vec3 uCameraPos;
uniform vec3 uAmbientLight;
// Directional light properties (nested in a struct)
uniform struct {
    vec3 mDirection;
    vec3 mDiffuseColor;
    vec3 mSpecColor;
} uDirLight;
// Material
uniform float uSpecPower;
uniform sampler2D uTexture;

void main() {
    // --- Vector Calculations ---
    // Normalize the surface normal
    vec3 N = normalize(fragNormal);
    // Vector from the surface point to the light source
    vec3 L = normalize(-uDirLight.mDirection);
    // Vector from the surface point to the camera
    vec3 V = normalize(uCameraPos - fragWorldPos);
    // Reflection of the light vector across the normal
    vec3 R = normalize(reflect(-L, N));

    // --- Phong Reflection Model ---
    // 1. Ambient term: a base light level
    vec3 Phong = uAmbientLight;
    
    // 2. Diffuse term: simulates directional light scattering
    float NdotL = dot(N, L);
    if (NdotL > 0) { // Only light surfaces facing the light
        vec3 Diffuse = uDirLight.mDiffuseColor * NdotL;
        
        // 3. Specular term: simulates shiny highlights
        float RdotV = max(0.0, dot(R, V));
        vec3 Specular = uDirLight.mSpecColor * pow(RdotV, uSpecPower);
        
        Phong += Diffuse + Specular;
    }

    // Final color is the texture color modulated by the calculated light
    outColor = texture(uTexture, fragTexCoord) * vec4(Phong, 1.0f);
}
```

### Step 8.2: Implement Lighting in Renderer

We need to pass the lighting data from our C++ code to the shader uniforms. Our implementation centrally manages lighting settings in the `Renderer` class.

Add to `src/Renderer.cpp`:
```cpp
void Renderer::SetLightUniforms(Shader* shader) {
    // Camera position is calculated from the inverted view matrix
    Matrix4 invView = mView;
    invView.Invert();
    shader->SetVectorUniform("uCameraPos", invView.GetTranslation());
    
    // Set ambient light level
    shader->SetVectorUniform("uAmbientLight", mAmbientLight);
    
    // Set directional light properties using struct notation
    shader->SetVectorUniform("uDirLight.mDirection", mDirLight.mDirection);
    shader->SetVectorUniform("uDirLight.mDiffuseColor", mDirLight.mDiffuseColor);
    shader->SetVectorUniform("uDirLight.mSpecColor", mDirLight.mSpecColor);
    
    // Set a default specular power value for all objects
    // In a more advanced system, this could be per-material
    shader->SetFloatUniform("uSpecPower", 100.0f);
}
```

This lighting implementation uses a centralized approach where all objects share the same specular power value. The renderer calls `SetLightUniforms()` once per frame before rendering all mesh components, ensuring consistent lighting across the entire scene.

---

## 9. Camera and Movement

A camera is just an actor that we use to generate the view matrix. By moving this actor, we move the camera.

### Step 9.1: Create Camera Actor

`include/CameraActor.hpp` defines a simple actor that will serve as our camera.

```cpp
#pragma once
#include "Actor.hpp"

class CameraActor : public Actor {
public:
    CameraActor(class Game* game);

    void UpdateActor(float deltaTime) override;
    void ActorInput(const uint8_t* keys) override;

private:
    class MoveComponent* mMoveComp;
};
```

### Step 9.2: Implement Camera Actor

In `src/CameraActor.cpp`, we update the renderer's view matrix every frame based on the camera's position and orientation.

```cpp
#include "CameraActor.hpp"
#include "MoveComponent.hpp"
#include "Game.hpp"
#include "Renderer.hpp"
#include "SDL_scancode.h"

CameraActor::CameraActor(Game* game) : Actor(game) {
    // Give the camera a move component
    mMoveComp = new MoveComponent(this);
}

void CameraActor::UpdateActor(float deltaTime) {
    Actor::UpdateActor(deltaTime);

    // Create the view matrix using the "Look-At" function
    Vector3 cameraPos = GetPosition();
    // The target is a point 100 units in front of the camera
    Vector3 target = GetPosition() + GetForward() * 100.0f;
    // The "up" vector is along the world's Z-axis
    Vector3 up = Vector3::UnitZ;

    Matrix4 view = Matrix4::CreateLookAt(cameraPos, target, up);
    // Tell the renderer to use this new view matrix
    GetGame()->GetRenderer()->SetViewMatrix(view);
}

void CameraActor::ActorInput(const uint8_t* keys) {
    float forwardSpeed = 0.0f;
    float angularSpeed = 0.0f;

    // Simple WASD controls for movement
    if (keys[SDL_SCANCODE_W]) { forwardSpeed += 300.0f; }
    if (keys[SDL_SCANCODE_S]) { forwardSpeed -= 300.0f; }
    if (keys[SDL_SCANCODE_A]) { angularSpeed -= Math::TwoPi; }
    if (keys[SDL_SCANCODE_D]) { angularSpeed += Math::TwoPi; }

    mMoveComp->SetForwardSpeed(forwardSpeed);
    mMoveComp->SetAngularSpeed(angularSpeed);
}
```

### Step 9.3: Create Move Component

The `MoveComponent` encapsulates the logic for movement, which can be reused by any actor.

`include/MoveComponent.hpp`:
```cpp
#pragma once
#include "Component.hpp"

class MoveComponent : public Component {
public:
    // Lower update order to ensure movement happens before other logic
    MoveComponent(class Actor* owner, int updateOrder = 10);

    void Update(float deltaTime) override;

    // Getters and setters for speeds
    float GetAngularSpeed() const { return mAngularSpeed; }
    float GetForwardSpeed() const { return mForwardSpeed; }
    void SetAngularSpeed(float speed) { mAngularSpeed = speed; }
    void SetForwardSpeed(float speed) { mForwardSpeed = speed; }

private:
    float mAngularSpeed; // In radians/second
    float mForwardSpeed; // In units/second
};
```

### Step 9.4: Implement Move Component

`src/MoveComponent.cpp` updates the owner actor's position and rotation based on its speeds.

```cpp
#include "MoveComponent.hpp"
#include "Actor.hpp"
#include "Math.hpp" // For NearZero

MoveComponent::MoveComponent(Actor* owner, int updateOrder)
    : Component(owner, updateOrder), mAngularSpeed(0.0f), mForwardSpeed(0.0f) {}

void MoveComponent::Update(float deltaTime) {
    // Update rotation
    if (!Math::NearZero(mAngularSpeed)) {
        Quaternion rot = mOwner->GetRotation();
        float angle = mAngularSpeed * deltaTime;
        // Create a quaternion for rotation about the Z-axis
        Quaternion inc(Vector3::UnitZ, angle);
        // Concatenate to combine rotations
        rot = Quaternion::Concatenate(rot, inc);
        mOwner->SetRotation(rot);
    }

    // Update position
    if (!Math::NearZero(mForwardSpeed)) {
        Vector3 pos = mOwner->GetPosition();
        // Move along the actor's forward vector
        pos += mOwner->GetForward() * mForwardSpeed * deltaTime;
        mOwner->SetPosition(pos);
    }
}
```

---

## 10. Input Handling

We need to poll for keyboard state and pass it to our actors.

### Step 10.1: Implement Game Input Processing

This function in `src/Game.cpp` handles window events and keyboard state.

```cpp
void Game::ProcessInput() {
    SDL_Event event;
    // Poll for window events (like closing the window)
    while (SDL_PollEvent(&event)) {
        switch (event.type) {
        case SDL_QUIT:
            mIsRunning = false;
            break;
        }
    }

    // Get the current state of the keyboard
    const Uint8* keyboardState = SDL_GetKeyboardState(NULL);
    // Exit on ESCAPE key
    if (keyboardState[SDL_SCANCODE_ESCAPE]) {
        mIsRunning = false;
    }

    // Pass the keyboard state to all actors for processing
    mUpdatingActors = true;
    for (auto actor : mActors) {
        actor->ProcessInput(keyboardState);
    }
    mUpdatingActors = false;
}
```

### Step 10.2: Create Input Component Base

For non-camera actors, we can create a more configurable `InputComponent`. This is left as an exercise but would allow setting keys and speeds for AI or player-controlled pawns.

`include/InputComponent.hpp`:
```cpp
#pragma once
#include "MoveComponent.hpp"

class InputComponent : public MoveComponent {
public:
    InputComponent(class Actor* owner);
    void ProcessInput(const uint8_t* keyState) override;

    // Getters/setters for keys and speeds...
private:
    float mMaxForwardSpeed;
    float mMaxAngularSpeed;
    int mForwardKey;
    int mBackKey;
    // ... and so on
};
```

---

## 11. Game Loop Integration

Now we tie everything together in the main game loop.

### Step 11.1: Implement Complete Game Loop

The full game loop implementation in `src/Game.cpp`.

```cpp
void Game::RunLoop() {
    while (mIsRunning) {
        ProcessInput();
        UpdateGame();
        GenerateOutput();
    }
}

void Game::UpdateGame() {
    // Simple frame rate limiting to ~60 FPS
    while (!SDL_TICKS_PASSED(SDL_GetTicks(), mTicksCount + 16));

    // Calculate delta time (time since last frame)
    float deltaTime = (SDL_GetTicks() - mTicksCount) / 1000.0f;
    // Clamp max delta time to prevent large jumps
    if (deltaTime > 0.05f) {
        deltaTime = 0.05f;
    }
    mTicksCount = SDL_GetTicks();

    // Update all actors
    mUpdatingActors = true;
    for (auto actor : mActors) {
        actor->Update(deltaTime);
    }
    mUpdatingActors = false;

    // Add any pending actors to the main actor list
    for (auto pending : mPendingActors) {
        pending->ComputeWorldTransform();
        mActors.emplace_back(pending);
    }
    mPendingActors.clear();

    // Remove and delete any dead actors
    std::vector<Actor*> deadActors;
    for (auto actor : mActors) {
        if (actor->GetState() == Actor::EDead) {
            deadActors.emplace_back(actor);
        }
    }
    for (auto actor : deadActors) {
        delete actor;
    }
}

void Game::GenerateOutput() {
    // This just calls the renderer's draw function
    mRenderer->Draw();
}
```

### Step 11.2: Complete Renderer Draw Function

The `Draw` function in `src/Renderer.cpp` sets up the graphics pipeline state and draws all the meshes and sprites.

```cpp
void Renderer::Draw() {
    // Clear the back buffer to a color
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    // Also clear the depth buffer
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    // --- Draw 3D Meshes ---
    // Enable depth testing and disable blending
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_BLEND);
    
    // Activate the lit mesh shader
    mMeshShader->SetActive();
    // Set the view-projection matrix
    mMeshShader->SetMatrixUniform("uViewProj", mView * mProjection);
    // Set lighting uniforms
    SetLightUniforms(mMeshShader);
    
    // Draw all mesh components
    for (auto mc : mMeshComps) {
        mc->Draw(mMeshShader);
    }

    // --- Draw 2D Sprites (UI) ---
    // Disable depth testing and enable alpha blending
    glDisable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // Activate the sprite shader
    mSpriteShader->SetActive();
    mSpriteVerts->SetActive();
    
    // Draw all sprite components
    for (auto sprite : mSprites) {
        sprite->Draw(mSpriteShader);
    }

    // Swap the front and back buffers to display the rendered scene
    SDL_GL_SwapWindow(mWindow);
}
```

### Step 11.3: Load Initial Game Data

In `src/Game.cpp`, we create a complete 3D scene with test objects, a detailed environment, and UI elements in `LoadData`.

```cpp
void Game::LoadData() {
    // Create test objects
    Actor* a = new Actor(this);
    a->SetPosition(Vector3(200.0f, 75.0f, 0.0f));
    a->SetScale(100.0f);
    // Apply complex rotation using quaternions
    Quaternion q(Vector3::UnitY, -Math::PiOver2);
    q = Quaternion::Concatenate(q, Quaternion(Vector3::UnitZ, Math::Pi + Math::Pi / 4.0f));
    a->SetRotation(q);
    MeshComponent* mc = new MeshComponent(a);
    mc->SetMesh(mRenderer->GetMesh("../assets/Cube.gpmesh"));

    // Create a sphere actor
    a = new Actor(this);
    a->SetPosition(Vector3(200.0f, -75.0f, 0.0f));
    a->SetScale(3.0f);
    mc = new MeshComponent(a);
    mc->SetMesh(mRenderer->GetMesh("../assets/Sphere.gpmesh"));

    // Create a detailed environment using PlaneActor
    const float start = -1250.0f;
    const float size = 250.0f;
    
    // Create a 10x10 grid floor using PlaneActors
    for (int i = 0; i < 10; i++) {
        for (int j = 0; j < 10; j++) {
            a = new PlaneActor(this);
            a->SetPosition(Vector3(start + i * size, start + j * size, -100.0f));
        }
    }

    // Create left/right walls
    q = Quaternion(Vector3::UnitX, Math::PiOver2);
    for (int i = 0; i < 10; i++) {
        a = new PlaneActor(this);
        a->SetPosition(Vector3(start + i * size, start - size, 0.0f));
        a->SetRotation(q);

        a = new PlaneActor(this);
        a->SetPosition(Vector3(start + i * size, -start + size, 0.0f));
        a->SetRotation(q);
    }

    // Create forward/back walls
    q = Quaternion::Concatenate(q, Quaternion(Vector3::UnitZ, Math::PiOver2));
    for (int i = 0; i < 10; i++) {
        a = new PlaneActor(this);
        a->SetPosition(Vector3(start - size, start + i * size, 0.0f));
        a->SetRotation(q);

        a = new PlaneActor(this);
        a->SetPosition(Vector3(-start + size, start + i * size, 0.0f));
        a->SetRotation(q);
    }

    // Set up realistic lighting
    mRenderer->SetAmbientLight(Vector3(0.2f, 0.2f, 0.2f));
    DirectionalLight& dir = mRenderer->GetDirectionalLight();
    dir.mDirection = Vector3(0.0f, -0.707f, -0.707f);
    dir.mDiffuseColor = Vector3(0.78f, 0.88f, 1.0f);
    dir.mSpecColor = Vector3(0.8f, 0.8f, 0.8f);

    // Create the camera
    mCameraActor = new CameraActor(this);

    // Create UI elements using the sprite system
    a = new Actor(this);
    a->SetPosition(Vector3(-350.0f, -350.0f, 0.0f));
    SpriteComponent* sc = new SpriteComponent(a);
    sc->SetTexture(mRenderer->GetTexture("../assets/HealthBar.png"));

    a = new Actor(this);
    a->SetPosition(Vector3(375.0f, -275.0f, 0.0f));
    a->SetScale(0.75f);
    sc = new SpriteComponent(a);
    sc->SetTexture(mRenderer->GetTexture("../assets/Radar.png"));
}
```

This `LoadData` function creates a comprehensive test scene featuring:
- **Test Objects**: A rotated cube and sphere for visual reference
- **Complex Environment**: A complete room with floor and four walls (130 PlaneActor instances total)
- **Realistic Lighting**: Ambient lighting plus directional light from above-left
- **Interactive Camera**: First-person camera with WASD controls
- **UI Elements**: Health bar and radar sprites positioned as HUD elements

The scene demonstrates all major engine systems working together: 3D rendering, lighting, actor-component architecture, specialized actor types, and 2D UI overlay.

---

## 12. Advanced Features

This guide provides the foundation. Here are some next steps to build a more feature-complete engine.

## 12. UI and Sprite System

The engine includes a complete 2D sprite rendering system for UI elements, overlays, and HUD components.

### Step 12.1: Sprite Component Implementation

`include/SpriteComponent.hpp` defines the sprite component interface:
```cpp
#pragma once
#include "Component.hpp"

class SpriteComponent : public Component {
public:
    SpriteComponent(Actor* owner, int drawOrder = 100);
    ~SpriteComponent();

    virtual void Draw(Shader* shader);
    virtual void SetTexture(Texture* texture);

    int GetDrawOrder() const { return mDrawOrder; }
    int GetTexHeight() const { return mTextHeight; }
    int GetTexWidth() const { return mTexWidth; }

protected:
    Texture* mTexture;
    int mDrawOrder;      // Controls render order (lower draws first)
    int mTextHeight;
    int mTexWidth;
};
```

`src/SpriteComponent.cpp` implements the sprite rendering logic:
```cpp
#include "SpriteComponent.hpp"
#include "Actor.hpp"
#include "Game.hpp"
#include "Shader.hpp"
#include "Texture.hpp"
#include "Math.hpp"
#include <GL/glew.h>

SpriteComponent::SpriteComponent(Actor* owner, int drawOrder)
    : Component(owner), mTexture(nullptr), mDrawOrder(drawOrder), 
      mTexWidth(0), mTextHeight(0) {
    // Register this sprite with the renderer
    mOwner->GetGame()->GetRenderer()->AddSprite(this);
}

SpriteComponent::~SpriteComponent() {
    mOwner->GetGame()->GetRenderer()->RemoveSprite(this);
}

void SpriteComponent::Draw(Shader* shader) {
    if (mTexture) {
        // Scale the quad by the texture's dimensions
        // Use default size if texture dimensions are unavailable
        float width = mTexWidth > 0 ? static_cast<float>(mTexWidth) : 64.0f;
        float height = mTextHeight > 0 ? static_cast<float>(mTextHeight) : 64.0f;
        Matrix4 scaleMat = Matrix4::CreateScale(width, height, 1.0f);

        // Combine with actor's world transform
        Matrix4 world = scaleMat * mOwner->GetWorldTransform();

        // Set world transform uniform
        shader->SetMatrixUniform("uWorldTransform", world);

        // Activate the texture and draw
        mTexture->SetActive();
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
    }
}

void SpriteComponent::SetTexture(Texture* texture) {
    mTexture = texture;
    // Cache texture dimensions
    mTexWidth = texture->GetWidth();
    mTextHeight = texture->GetHeight();
}
```

### Step 12.2: Sprite Shaders

The sprite system uses dedicated shaders optimized for 2D rendering with orthographic projection.

`shaders/Sprite.vert`:
```glsl
#version 330

// Input vertex attributes
layout(location = 0) in vec3 inPosition;
layout(location = 1) in vec3 inNormal;
layout(location = 2) in vec2 inTexCoord;

// Uniforms
uniform mat4 uWorldTransform;
uniform mat4 uViewProj;

// Output to fragment shader
out vec2 fragTexCoord;

void main() {
    // Transform position to clip space
    vec4 pos = vec4(inPosition, 1.0);
    pos = pos * uWorldTransform;
    gl_Position = pos * uViewProj;
    
    // Pass through texture coordinate
    fragTexCoord = inTexCoord;
}
```

`shaders/Sprite.frag`:
```glsl
#version 330

// Input from vertex shader
in vec2 fragTexCoord;

// Uniforms
uniform sampler2D uTexture;

// Output color
out vec4 outColor;

void main() {
    // Sample the texture
    outColor = texture(uTexture, fragTexCoord);
}
```

### Step 12.3: Sprite Rendering Pipeline

In `src/Renderer.cpp`, sprites are rendered after 3D meshes with specific OpenGL state:
```cpp
void Renderer::Draw() {
    // ... 3D mesh rendering ...
    
    // Draw all sprite components with 2D settings
    glDisable(GL_DEPTH_TEST);  // Disable depth testing for UI
    glEnable(GL_BLEND);        // Enable alpha blending
    glBlendEquationSeparate(GL_FUNC_ADD, GL_FUNC_ADD);
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);

    // Activate sprite shader and vertex array
    mSpriteShader->SetActive();
    mSpriteVerts->SetActive();
    
    // Draw sprites in draw order (sorted by renderer)
    for (auto sprite : mSprites) {
        sprite->Draw(mSpriteShader);
    }
    
    // Swap buffers
    SDL_GL_SwapWindow(mWindow);
}
```

This system allows for easy creation of UI elements like health bars, radars, and crosshairs by simply attaching a `SpriteComponent` to an actor and positioning it appropriately.

## 13. Asset Loading and File Formats

Our engine uses custom file formats and texture loading systems for optimal performance and control.

### Step 13.1: Custom Mesh Format (.gpmesh)

The engine uses a custom `.gpmesh` format for 3D models, which provides efficient loading and includes all necessary data:
- Vertex positions, normals, and texture coordinates
- Index data for triangle rendering
- Material properties (specular power, texture references)
- Bounding volume information for collision detection

Assets you'll commonly work with:
- `Cube.gpmesh` - Basic cube primitive
- `Sphere.gpmesh` - Sphere primitive for testing
- `Plane.gpmesh` - Ground/wall tiles (used extensively)
- Associated `.png` texture files

### Step 13.2: Texture Class Implementation

The `Texture` class handles loading images from disk and uploading them to GPU memory using STB Image.

`include/Texture.hpp`:
```cpp
#pragma once
#include <string>

class Texture {
public:
    Texture();
    ~Texture();

    bool Load(const std::string& fileName);
    void Unload();
    void SetActive();

    int GetWidth() const { return mWidth; }
    int GetHeight() const { return mHeight; }

private:
    unsigned int mTextureId; // OpenGL texture ID
    int mWidth;
    int mHeight;
};
```

`src/Texture.cpp` implements the complete texture loading pipeline:
```cpp
#include "Texture.hpp"
#include "SDL_log.h"
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
#include <GL/glew.h>

Texture::Texture() : mTextureId(0), mWidth(0), mHeight(0) {}

Texture::~Texture() {}

bool Texture::Load(const std::string& fileName) {
    int channels = 0;
    // Load image data using STB Image, force 4 channels (RGBA)
    unsigned char* data = stbi_load(fileName.c_str(), &mWidth, &mHeight, &channels, 4);

    if (data) {
        // Generate OpenGL texture object
        glGenTextures(1, &mTextureId);
        glBindTexture(GL_TEXTURE_2D, mTextureId);

        // Upload pixel data to GPU (forced RGBA format)
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, mWidth, mHeight, 0, GL_RGBA,
                     GL_UNSIGNED_BYTE, data);

        // Free CPU memory
        stbi_image_free(data);

        // Set filtering parameters for smooth scaling
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        SDL_Log("Successfully loaded texture %s (%dx%d)", fileName.c_str(), mWidth, mHeight);
        return true;
    } else {
        SDL_Log("Failed to load image %s: %s", fileName.c_str(), stbi_failure_reason());
        return false;
    }
}

void Texture::Unload() { 
    glDeleteTextures(1, &mTextureId); 
}

void Texture::SetActive() { 
    glBindTexture(GL_TEXTURE_2D, mTextureId); 
}
```

The renderer maintains a texture cache to avoid reloading:
```cpp
std::unordered_map<std::string, class Texture*> mTextures;
std::unordered_map<std::string, class Mesh*> mMeshes;
```

### Step 13.3: Advanced Asset Formats

For more complex scenes, the engine supports:
- `.gpskel` - Skeletal animation data
- `.gpanim` - Animation sequences 
- `.gplevel` - Level layout and actor placement data
- `.gptext` - Localized text resources (English.gptext, Russian.gptext)

### Step 12.3: Audio System
Integrate an audio library like `SDL_mixer` or `FMOD`. Create an `AudioSystem` class to manage loading and playing sounds. You can then create an `AudioComponent` to attach sounds to actors, allowing for 3D positional audio.

## 15. Collision Detection System

The engine includes a simple collision detection system using circular collision boundaries.

### Step 15.1: CircleComponent for Collision

`include/CircleComponent.hpp`:
```cpp
#pragma once
#include "Component.hpp"

class CircleComponent : public Component {
public:
    CircleComponent(Actor* owner);

    void SetRadius(float radius) { mRadius = radius; }
    float GetRadius() const;
    const Vector3& GetCenter() const;

private:
    float mRadius;
};

// Global collision detection function
bool Intersect(const CircleComponent& a, const CircleComponent& b);
```

`src/CircleComponent.cpp`:
```cpp
#include "CircleComponent.hpp"
#include "Actor.hpp"
#include "Math.hpp"

CircleComponent::CircleComponent(Actor* owner)
    : Component(owner), mRadius(0.0f) {}

const Vector3& CircleComponent::GetCenter() const {
    return mOwner->GetPosition();
}

float CircleComponent::GetRadius() const {
    // Scale radius by actor's scale factor
    return mOwner->GetScale() * mRadius;
}

bool Intersect(const CircleComponent& a, const CircleComponent& b) {
    // Calculate distance squared between centers
    Vector3 diff = a.GetCenter() - b.GetCenter();
    float distSq = diff.LengthSq();

    // Calculate sum of radii squared
    float radiiSq = a.GetRadius() + b.GetRadius();
    radiiSq *= radiiSq;

    return distSq <= radiiSq;
}
```

## 16. Advanced Input System

Beyond the camera's hardcoded input, the engine provides a configurable input component.

### Step 16.1: InputComponent Implementation

`include/InputComponent.hpp`:
```cpp
#pragma once
#include "MoveComponent.hpp"
#include <cstdint>

class InputComponent : public MoveComponent {
public:
    InputComponent(Actor* owner);
    void ProcessInput(const uint8_t* keyState) override;

    // Getters/setters for customization
    float GetMaxForward() const { return mMaxForwardSpeed; }
    float GetMaxAngular() const { return mMaxAngularSpeed; }
    int GetForwardKey() const { return mForwardKey; }
    int GetBackKey() const { return mBackKey; }
    int GetClockwiseKey() const { return mClockwiseKey; }
    int GetCounterClockwiseKey() const { return mCounterClockwiseKey; }

    void SetMaxForwardSpeed(float speed) { mMaxForwardSpeed = speed; }
    void SetMaxAngularSpeed(float speed) { mMaxAngularSpeed = speed; }
    void SetForwardKey(int key) { mForwardKey = key; }
    void SetBackKey(int key) { mBackKey = key; }
    void SetClockwiseKey(int key) { mClockwiseKey = key; }
    void SetCounterClockwiseKey(int key) { mCounterClockwiseKey = key; }

private:
    float mMaxForwardSpeed;
    float mMaxAngularSpeed;
    int mForwardKey;
    int mBackKey;
    int mClockwiseKey;
    int mCounterClockwiseKey;
};
```

`src/InputComponent.cpp`:
```cpp
#include "InputComponent.hpp"
#include "Actor.hpp"

InputComponent::InputComponent(Actor* owner)
    : MoveComponent(owner), mForwardKey(0), mBackKey(0), 
      mClockwiseKey(0), mCounterClockwiseKey(0) {}

void InputComponent::ProcessInput(const uint8_t* keyState) {
    float forwardSpeed = 0.0f;
    if (keyState[mForwardKey]) {
        forwardSpeed += mMaxForwardSpeed;
    }
    if (keyState[mBackKey]) {
        forwardSpeed -= mMaxForwardSpeed;
    }
    SetForwardSpeed(forwardSpeed);

    float angularSpeed = 0.0f;
    if (keyState[mClockwiseKey]) {
        angularSpeed += mMaxAngularSpeed;
    }
    if (keyState[mCounterClockwiseKey]) {
        angularSpeed -= mMaxAngularSpeed;
    }
    SetAngularSpeed(angularSpeed);
}
```

This allows creating actors with customizable controls:
```cpp
// Create a player-controlled actor
Actor* player = new Actor(this);
InputComponent* input = new InputComponent(player);
input->SetForwardKey(SDL_SCANCODE_W);
input->SetBackKey(SDL_SCANCODE_S);
input->SetClockwiseKey(SDL_SCANCODE_D);
input->SetCounterClockwiseKey(SDL_SCANCODE_A);
input->SetMaxForwardSpeed(300.0f);
input->SetMaxAngularSpeed(Math::TwoPi);
```

---

## Summary

This guide has walked through the essential steps to create a functional 3D game engine.

1.  **Project Setup**: Configured a clean project with CMake and essential libraries.
2.  **Window Creation**: Used SDL to create a window and an OpenGL 3.3 context.
3.  **Renderer**: Built a rendering pipeline to manage resources and draw scenes.
4.  **Shaders**: Created a system for loading and using GLSL shaders.
5.  **Math Library**: Implemented core 3D math constructs.
6.  **Actor-Component System**: Designed a flexible architecture for game objects.
7.  **Mesh System**: Loaded and rendered 3D models.
8.  **Lighting**: Implemented the Phong reflection model for realistic lighting.
9.  **Camera**: Created a movable first-person camera.
10. **Input**: Handled keyboard input for camera control and game events.
11. **Game Loop**: Integrated all systems into a robust main loop.
12. **Advanced Features**: Outlined next steps for UI, audio, and physics.

This engine provides a powerful and extensible foundation for building your own 3D games.
